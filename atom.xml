<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝸牛</title>
  <subtitle>小小的天有大大的夢想</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.abandonzhang.me/"/>
  <updated>2018-02-08T16:18:05.581Z</updated>
  <id>http://blog.abandonzhang.me/</id>
  
  <author>
    <name>AbandonZHANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Basic IO</title>
    <link href="http://blog.abandonzhang.me/2018/02/05/Java-Basic-IO/"/>
    <id>http://blog.abandonzhang.me/2018/02/05/Java-Basic-IO/</id>
    <published>2018-02-05T10:03:07.000Z</published>
    <updated>2018-02-08T16:18:05.581Z</updated>
    
    <content type="html">&lt;p&gt;未完待续。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;未完待续。&lt;/p&gt;

    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SkipList 入门</title>
    <link href="http://blog.abandonzhang.me/2018/01/19/SkipList/"/>
    <id>http://blog.abandonzhang.me/2018/01/19/SkipList/</id>
    <published>2018-01-19T09:32:16.000Z</published>
    <updated>2018-02-08T16:01:13.748Z</updated>
    
    <content type="html">&lt;p&gt;介绍一个插入/查询复杂度可以媲美红黑树，但实现起来更简单的数据结构 —— SkipList。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;SkipList 是一个多层次的链表数据结构，用来代替红黑树等自平衡二叉查找树。它具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解、实现简单&lt;/li&gt;
&lt;li&gt;均摊时间复杂度与自平衡二叉查找树相当&lt;/li&gt;
&lt;li&gt;插入、删除操作简单，高并发环境下优势较大&lt;/li&gt;
&lt;li&gt;容易实现线程安全的版本&lt;/li&gt;
&lt;li&gt;范围查询效率高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用范围&quot;&gt;&lt;a href=&quot;#应用范围&quot; class=&quot;headerlink&quot; title=&quot;应用范围&quot;&gt;&lt;/a&gt;应用范围&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Redis - 使用 SkipList 实现其 Sorted Set 数据结构&lt;/li&gt;
&lt;li&gt;LevelDB&lt;/li&gt;
&lt;li&gt;Lucene&lt;/li&gt;
&lt;li&gt;Jdk - ConcurrentSkipListMap, ConcurrentSkipListSet&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/SkipList_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图 a ：普通的 Linked List（level 0）。查询某个 key 的时间复杂度为 O(N)&lt;/li&gt;
&lt;li&gt;图 b ：在 level 0 List 的基础上新增一层 level 1 List（间隔部分元素），同时，同一位置的元素切换到另一个 level List 的时间复杂度为常数级别&lt;br&gt;（为了简化问题，暂定间隔是均匀分布的。图 b 的间隔即为 2，则时间复杂度为：|L1| + |L0|/|L1| = O(N/2) + 2）&lt;/li&gt;
&lt;li&gt;图 c / d ：在 level i List 的基础上新增一层 level i+1 List。间隔仍为 2。时间复杂度为：|Lk| + |Lk-1|/|Lk| + |Lk-2|/|Lk-1| + … + |L0|/|L1|&lt;br&gt;（间隔为 2 时，最多可以建 log2N 层的 level，即 k= log2N，Lk 一般是1个或2个元素，因此最后的时间复杂度为 2 * log2N = O(log2N)）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理想很丰满，现实很骨感。维护一致间隔的成本很高，在插入和删除时均需要做大量调整，这样与自平衡二叉查找树相比不一定更有优势了。&lt;/p&gt;
&lt;p&gt;SkipList 的做法是：节点的最高 level 在插入时随机决定，此后不再发生变化&lt;/p&gt;
&lt;p&gt;具体的随机规则是：&lt;br&gt;&lt;figure class=&quot;highlight matlab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;定义概率p：表示当节点有 level &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt; 时，同时会有 level &lt;span class=&quot;built_in&quot;&gt;i&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 level &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 开始，类似抛硬币，每次独立地判断本次概率是否大于p，大于则 level+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;令 L(N) = max level，则可以证明 L(N) = $log_{1/p}N$。当 p = 1/2 时，L(N) = $log_2N$。&lt;/p&gt;
&lt;h3 id=&quot;查询&quot;&gt;&lt;a href=&quot;#查询&quot; class=&quot;headerlink&quot; title=&quot;查询&quot;&gt;&lt;/a&gt;查询&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/SkipList_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中绿色和蓝色的就是查找路径&lt;br&gt;&lt;figure class=&quot;highlight cos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Search(list, searchKey)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; := list→header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := list→level downto &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;→forward[i]→key &amp;lt; searchKey &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; := &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;→forward[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; := &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;→forward[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;→key = searchKey then &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;→value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; failure&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入&quot;&gt;&lt;a href=&quot;#插入&quot; class=&quot;headerlink&quot; title=&quot;插入&quot;&gt;&lt;/a&gt;插入&lt;/h3&gt;&lt;p&gt;插入和删除的情况较复杂一点点，因为涉及到临近节点的指针变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/SkipList_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们需要记录下来搜索路径中每一个 level 的拐点元素，该元素可能在插入新节点后，该 level 下的 next 指针会发生变化（这里说可能，是因为新节点的 level 可能没有这么高，就不需要变化）&lt;/p&gt;
&lt;p&gt;插入的节点有两种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新节点 level 小于当前 List 最高 level，此时只需要遍历每一层 level，修复 next 指针即可&lt;/li&gt;
&lt;li&gt;新节点 level 高于当前 List 最高 level，此时需要把 head 节点也加入到 update[] 数组中，然后再去遍历每层 level，修复 next 指针&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Insert&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;, searchKey, newValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.MaxLevel]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; x→forward[i]→&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &amp;lt; searchKey &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x := x→forward[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i] := x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x := x→forward[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x→&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; = searchKey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 节点已存在，直接覆盖原值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x→&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; := newValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 节点不存在，插入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lvl := randomLevel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 新节点 &lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; 高于当前最大 &lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt;，补充 &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt; 数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; lvl &amp;gt; &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; lvl &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i] := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; := lvl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x := makeNode(lvl, searchKey, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 修复 &lt;span class=&quot;keyword&quot;&gt;next&lt;/span&gt; 指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x→forward[i] := &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i]→forward[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i]→forward[i] := x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;删除&quot;&gt;&lt;a href=&quot;#删除&quot; class=&quot;headerlink&quot; title=&quot;删除&quot;&gt;&lt;/a&gt;删除&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/SkipList_4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除阶段和插入差不多，也需要记录下来搜索路径中的每一层 level 的拐点元素（注意这里我们不能在 level &amp;gt; 1 的层级就找到这个元素结束流程，必须在 level = 1 这一层到达最终元素，以便记录搜索路径中的拐点元素）&lt;/p&gt;
&lt;p&gt;删除节点可能会造成 List 整体 level 的下降，因此在删除完节点，调整完 next 指针后还需要调整一下 head 节点的 level（直接指向 NIL 的 level 就可以去掉了）&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Delete&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;, searchKey)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.MaxLevel]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; x→forward[i]→&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &amp;lt; searchKey &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x := x→forward[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i] := x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x := x→forward[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x→&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; = searchKey &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i]→forward[i] ≠ x &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;[i]→forward[i] := x→forward[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        free(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→header→forward[&lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt;] = NIL &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; := &lt;span class=&quot;keyword&quot;&gt;list&lt;/span&gt;→&lt;span class=&quot;keyword&quot;&gt;level&lt;/span&gt; – &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;退化&quot;&gt;&lt;a href=&quot;#退化&quot; class=&quot;headerlink&quot; title=&quot;退化&quot;&gt;&lt;/a&gt;退化&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/SkipList_5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种情况下查询性能甚至不如普通链表，不过出现这种情况的几率并不大。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Skip Lists: A Probabilistic Alternative to Balanced Trees —— William Pugh &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/readings/l12_skiplists.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MIT - Introduction to Algorithms - skiplist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码：可以参考 Redis 和 JDK 的实现&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;介绍一个插入/查询复杂度可以媲美红黑树，但实现起来更简单的数据结构 —— SkipList。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://blog.abandonzhang.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM 参数总结</title>
    <link href="http://blog.abandonzhang.me/2017/12/04/JVM-Args-Summary/"/>
    <id>http://blog.abandonzhang.me/2017/12/04/JVM-Args-Summary/</id>
    <published>2017-12-04T15:56:37.000Z</published>
    <updated>2018-02-08T16:15:58.945Z</updated>
    
    <content type="html">&lt;p&gt;记录一下自己学习过的 JVM 启动参数。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;标准参数&quot;&gt;&lt;a href=&quot;#标准参数&quot; class=&quot;headerlink&quot; title=&quot;标准参数&quot;&gt;&lt;/a&gt;标准参数&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-server&lt;/td&gt;
&lt;td&gt;以 server 模式运行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;X-参数&quot;&gt;&lt;a href=&quot;#X-参数&quot; class=&quot;headerlink&quot; title=&quot;-X 参数&quot;&gt;&lt;/a&gt;-X 参数&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-Xmx3g&lt;/td&gt;
&lt;td&gt;设置堆最大空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-Xms3g&lt;/td&gt;
&lt;td&gt;设置堆初始空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;XX-参数&quot;&gt;&lt;a href=&quot;#XX-参数&quot; class=&quot;headerlink&quot; title=&quot;-XX 参数&quot;&gt;&lt;/a&gt;-XX 参数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;-XX:+DisableExplicitGC&lt;/code&gt;：System.gc() 变成空调用&lt;/p&gt;
&lt;h3 id=&quot;CMS-垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS 垃圾回收器&quot;&gt;&lt;/a&gt;CMS 垃圾回收器&lt;/h3&gt;&lt;p&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;：使用 CMS 垃圾回收器（新生代默认使用 ParNew）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+ExplicitGCInvokesConcurrent&lt;/code&gt;：System.gc() 时使用 CMS gc 替换 Full gc&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses&lt;/code&gt;：System.gc() 时使用 CMS gc 替换 Full gc，并且方法区（Perm）也在回收范围内&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:CMSInitiatingOccupancyFraction=80%&lt;/code&gt;：CMS 第一次 gc 时参考的 old 区空间占用比例&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+CMSInitiatingOccupancyOnly&lt;/code&gt;：强制 JVM 不基于运行时收集的数据动态调整 gc 时空间占比阈值，每次都使用 CMSInitiatingOccupancyFraction 的值&lt;/p&gt;
&lt;h3 id=&quot;G1-垃圾回收器&quot;&gt;&lt;a href=&quot;#G1-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;G1 垃圾回收器&quot;&gt;&lt;/a&gt;G1 垃圾回收器&lt;/h3&gt;&lt;p&gt;&lt;code&gt;-XX:+UseG1GC&lt;/code&gt;：使用 G1 垃圾回收器（新生代&amp;amp;&amp;amp;老年代）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己学习过的 JVM 启动参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>The OAuth 2.0 Authorization Framework 入门</title>
    <link href="http://blog.abandonzhang.me/2017/11/12/OAuth-2-0-Authorization-Framework/"/>
    <id>http://blog.abandonzhang.me/2017/11/12/OAuth-2-0-Authorization-Framework/</id>
    <published>2017-11-12T03:43:55.000Z</published>
    <updated>2018-02-08T16:14:44.187Z</updated>
    
    <content type="html">&lt;p&gt;学习一下业界标准的第三方应用授权框架 —— OAuth 协议。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;角色（Roles）&quot;&gt;&lt;a href=&quot;#角色（Roles）&quot; class=&quot;headerlink&quot; title=&quot;角色（Roles）&quot;&gt;&lt;/a&gt;角色（Roles）&lt;/h2&gt;&lt;p&gt;OAuth 2.0 标准中定义了四种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resource server&lt;/code&gt;（&lt;code&gt;资源服务&lt;/code&gt;） - 托管受保护资源的服务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resource owner&lt;/code&gt;（&lt;code&gt;用户&lt;/code&gt;） - 拥有某个受保护资源的授权资格的实体。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt;：（&lt;code&gt;第三方应用&lt;/code&gt;） - 需要访问某个受保护资源的应用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;authorization server&lt;/code&gt;（&lt;code&gt;授权服务&lt;/code&gt;）：颁发可信的授权令牌（&lt;code&gt;token&lt;/code&gt;）的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;授权服务和资源服务之间的交互不在标准的讨论范围中。两者可以是同一个。&lt;/p&gt;
&lt;h2 id=&quot;协议流程（Protocol-Flow）&quot;&gt;&lt;a href=&quot;#协议流程（Protocol-Flow）&quot; class=&quot;headerlink&quot; title=&quot;协议流程（Protocol Flow）&quot;&gt;&lt;/a&gt;协议流程（Protocol Flow）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/OAuth%202.0%20-%20Abstract%20Protocol%20Flow&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(A) 第三方应用向用户发起 &lt;code&gt;Authorization Request&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;(B) 用户授予第三方应用一个 &lt;code&gt;Authorization Grant&lt;/code&gt;，具体取决于选择哪种授权模式。&lt;/li&gt;
&lt;li&gt;(C) 第三方应用带着 &lt;code&gt;Authorization Grant&lt;/code&gt; 向授权服务发起请求。&lt;/li&gt;
&lt;li&gt;(D) 授权服务认证第三方应用的身份，校验 Authorization Grant ，然后向第三方应用颁发 &lt;code&gt;Access Token&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;(E) 第三方应用带着 Access Token 向资源服务发起请求。&lt;/li&gt;
&lt;li&gt;(F) 资源服务校验 Access Token 的合法性，返回受保护的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是一个抽象的框架定义，实际不完全是这个样子，具体的授权模式在流程上会有一些差异。&lt;/p&gt;
&lt;h2 id=&quot;应用注册（Client-Registration）&quot;&gt;&lt;a href=&quot;#应用注册（Client-Registration）&quot; class=&quot;headerlink&quot; title=&quot;应用注册（Client Registration）&quot;&gt;&lt;/a&gt;应用注册（Client Registration）&lt;/h2&gt;&lt;p&gt;第三方应用首先需要在授权服务上注册自己的认证信息，注册的方式不在标准的讨论范围中。（通常情况下，是授权服务提供一个带有注册表单的终端页面；也可以是其他的方式，比如授权服务有自己的一套应用自动发现的机制）&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：第三方应用向授权服务注册时必须提供以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;client type&lt;/code&gt; - 应用类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redirection URIs&lt;/code&gt; - 回调地址&lt;/li&gt;
&lt;li&gt;其他信息（如应用名，描述，logo等）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 id=&quot;应用类型（Client-Types）&quot;&gt;&lt;a href=&quot;#应用类型（Client-Types）&quot; class=&quot;headerlink&quot; title=&quot;应用类型（Client Types）&quot;&gt;&lt;/a&gt;应用类型（Client Types）&lt;/h3&gt;&lt;p&gt;OAuth 2.0 定义了两种应用类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;confidential&lt;/code&gt;: 可以保证自己的认证信息的安全性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;: 无法保证自己的认证信息的安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用类型会影响到授权服务在授权方式和安全方面的考虑。&lt;/p&gt;
&lt;p&gt;第三方应用被定义为哪种类型取决于授权服务对安全级别的定义以及他能接受的应用认证信息的安全级别。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务不应该对第三方应用的类型做任何的臆断。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;标准中主要提到了三种常见的应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;web application&lt;/code&gt;: confidential。认证信息通常保存在服务器端，不易暴露给外界。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user-agent-based application&lt;/code&gt;: public。认证信息通常保存在 user-agent 上，很容易暴露。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native application&lt;/code&gt;: public。认证信息通常保存在应用内部（代码或配置文件中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;应用回调地址（Redirection-URI）&quot;&gt;&lt;a href=&quot;#应用回调地址（Redirection-URI）&quot; class=&quot;headerlink&quot; title=&quot;应用回调地址（Redirection URI）&quot;&gt;&lt;/a&gt;应用回调地址（Redirection URI）&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：Redirection URI 必须是绝对路径。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;建议&lt;/strong&gt;：授权服务应该要求所有的 client 都注册完整格式的 Redirection URI，动态参数通过授权请求中的 “state” 参数来实现；如果有困难的话，也需要注册 URI 的 scheme、authority 和 path 部分，仅允许动态调整 query 参数。&lt;/p&gt;
&lt;p&gt;缺少 Redirection URI 的注册会导致授权请求页面变成一个 &lt;code&gt;open redirector&lt;/code&gt;，进而容易被攻击。（参见后续安全性考虑）&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;可以允许 client 注册多个 Redirection URI。&lt;/p&gt;
&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;strong&gt;不建议&lt;/strong&gt;：Redirection URI 请求中包含第三方 scripts。该页面中的任何第三方 scripts 都可以读取到 URI 中返回的授权信息（code 或 token）。建议在 Redirection URI 请求中首先将 URI 中返回的授权信息处理掉，然后再跳转到其他的 URI 处理业务逻辑。如果一定要包含第三方 scripts，client 必须保证自己处理 URI 中授权信息的方法优先于第三方 scripts 执行。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;应用标识（Client-Identifier）&quot;&gt;&lt;a href=&quot;#应用标识（Client-Identifier）&quot; class=&quot;headerlink&quot; title=&quot;应用标识（Client Identifier）&quot;&gt;&lt;/a&gt;应用标识（Client Identifier）&lt;/h3&gt;&lt;p&gt;第三方应用注册成功后，授权服务需要授予应用一个唯一标识符 &lt;code&gt;client_id&lt;/code&gt; —— 通过这个标识符可以唯一映射到第三方应用注册的其他信息。&lt;/p&gt;
&lt;p&gt;client_id 并不是密钥（client_secret），它可以暴露给外界，但不能作为身份认证时的唯一凭证。&lt;/p&gt;
&lt;h3 id=&quot;应用身份认证（Client-Authentication）&quot;&gt;&lt;a href=&quot;#应用身份认证（Client-Authentication）&quot; class=&quot;headerlink&quot; title=&quot;应用身份认证（Client Authentication）&quot;&gt;&lt;/a&gt;应用身份认证（Client Authentication）&lt;/h3&gt;&lt;p&gt;身份认证即验证身份的真实性，这里主要是授权服务验证 confidential client 的身份真实性。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务也可以验证 public client 的身份，但不能依赖对它的验证结果（因为它的身份是容易暴露和伪造的）。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;通常有以下几种身份认证方式：&lt;/p&gt;
&lt;h4 id=&quot;Password-client-secret&quot;&gt;&lt;a href=&quot;#Password-client-secret&quot; class=&quot;headerlink&quot; title=&quot;Password ( client_secret )&quot;&gt;&lt;/a&gt;Password ( client_secret )&lt;/h4&gt;&lt;p&gt;就是我们最经常使用的账号名和密码（clent_id 和 client_secret）。&lt;/p&gt;
&lt;p&gt;RFC 标准提供了一种 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP Basic Authentication&lt;/a&gt; 的认证算法来对第三方应用进行 password 方式的身份认证。&lt;/p&gt;
&lt;p&gt;当授权服务提供 password 方式的身份认证时，必须支持 HTTP BA 认证。也可以支持将认证信息放入 HTTP request body 中，但不推荐这么做，必须仅限于应用本身不支持 HTTP BA 认证的情况下。&lt;/p&gt;
&lt;p&gt;进行 password 认证的通信通道必须使用 TLS 加密。&lt;/p&gt;
&lt;h4 id=&quot;Assertions-RFC-7521&quot;&gt;&lt;a href=&quot;#Assertions-RFC-7521&quot; class=&quot;headerlink&quot; title=&quot;Assertions ( RFC 7521 )&quot;&gt;&lt;/a&gt;Assertions ( RFC 7521 )&lt;/h4&gt;&lt;p&gt;该方式非 OAuth 2.0 标准的内容，而是在单独的一个标准中。Assertions 认证主要是为了解决 public client 无法安全维护认证信息的问题。其认证过程概括地讲就是通过第三方可信认证机构来颁发动态证明，这里不细展开。&lt;/p&gt;
&lt;h2 id=&quot;授权模式（Obtaining-Authorization）&quot;&gt;&lt;a href=&quot;#授权模式（Obtaining-Authorization）&quot; class=&quot;headerlink&quot; title=&quot;授权模式（Obtaining Authorization）&quot;&gt;&lt;/a&gt;授权模式（Obtaining Authorization）&lt;/h2&gt;&lt;p&gt;授权模式指的是第三方应用获得用户授权以及从授权服务获取授权令牌的具体方式。&lt;/p&gt;
&lt;p&gt;OAuth 2.0 标准定义了四种授权模式：&lt;/p&gt;
&lt;h3 id=&quot;授权码授权模式（Authorization-Code-Grant）&quot;&gt;&lt;a href=&quot;#授权码授权模式（Authorization-Code-Grant）&quot; class=&quot;headerlink&quot; title=&quot;授权码授权模式（Authorization Code Grant）&quot;&gt;&lt;/a&gt;授权码授权模式（Authorization Code Grant）&lt;/h3&gt;&lt;p&gt;授权码是最安全的一种授权模式，应用在该模式下可以同时获得 access token 和 refresh token。该模式非常适合 confidential client 使用。&lt;/p&gt;
&lt;p&gt;下图是授权码授权的流程：&lt;br&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/OAuth%202.0%20-%20Authorization%20Code%20Flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;应用通过用户的 user-agent 与其交互。应用从用户那里得到的是一个临时的授权码，然后在应用的服务端去授权服务那里换取真正的 access token ，这样 access token 就不会暴露在用户的 user agent 中。&lt;/p&gt;
&lt;h3 id=&quot;隐式授权模式（Implicit-Grant）&quot;&gt;&lt;a href=&quot;#隐式授权模式（Implicit-Grant）&quot; class=&quot;headerlink&quot; title=&quot;隐式授权模式（Implicit Grant）&quot;&gt;&lt;/a&gt;隐式授权模式（Implicit Grant）&lt;/h3&gt;&lt;p&gt;阮一峰老师的博客中把它译为“简化模式”，个人认为不管从原文还是该模式本身讲都有些不准确。“Implicit” 一词正是该模式的精髓所在，不应该被忽略。我们来看下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/OAuth%202.0%20-%20Implicit%20Grant%20Flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意到该图和上一个模式有一个明显的区别：授权服务器向应用传递 access token 的方式是 Redirection URI with Access Token &lt;code&gt;in Fragment&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Fragment 是 URI 标准的一部分，表示一个主文档的子文档（片段）。在 HTTP 协议中，这部分内容不会被 user-agent 携带到远程访问的 URL 中，只会在 user-agent 本地起作用。&lt;/p&gt;
&lt;p&gt;当 access token 以 Fragment 的形式附加在 Redirection URI 中时，access token 只会保存在 user-agent 本地，不会暴露在不安全的网络环境中。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：该授权模式下，授权服务必须校验 Redirection URI 的合法性；并且不可以给应用返回 refresh token。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;用户密码授权模式（Resource-Owner-Password-Credentials-Grant）&quot;&gt;&lt;a href=&quot;#用户密码授权模式（Resource-Owner-Password-Credentials-Grant）&quot; class=&quot;headerlink&quot; title=&quot;用户密码授权模式（Resource Owner Password Credentials Grant）&quot;&gt;&lt;/a&gt;用户密码授权模式（Resource Owner Password Credentials Grant）&lt;/h3&gt;&lt;p&gt;即传统的用户名密码模式，适用于用户比较信任客户端环境的情况（比如自己机器的操作系统等）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/OAuth%202.0%20-%20Resource%20Owner%20Password%20Credentials%20Flow&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式安全性比较低，并且用户无法控制授权的粒度，应该尽量避免或不提供这种授权方式。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：应用每次得到授权服务的授权令牌后，必须丢弃掉用户的账号密码信息（一次性）。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;应用认证授权模式（Client-Credentials-Grant）&quot;&gt;&lt;a href=&quot;#应用认证授权模式（Client-Credentials-Grant）&quot; class=&quot;headerlink&quot; title=&quot;应用认证授权模式（Client Credentials Grant）&quot;&gt;&lt;/a&gt;应用认证授权模式（Client Credentials Grant）&lt;/h3&gt;&lt;p&gt;应用使用它的身份认证信息就可以直接获得授权。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/OAuth%202.0%20-%20Client%20Credentials%20Flow&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：该授权模式必须仅向 confidential client 提供；授权服务必须验证 client 的身份；并且不可以向 client 返回 refresh token。&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;请求与响应&quot;&gt;&lt;a href=&quot;#请求与响应&quot; class=&quot;headerlink&quot; title=&quot;请求与响应&quot;&gt;&lt;/a&gt;请求与响应&lt;/h2&gt;&lt;h3 id=&quot;Authorization-Request&quot;&gt;&lt;a href=&quot;#Authorization-Request&quot; class=&quot;headerlink&quot; title=&quot;Authorization Request&quot;&gt;&lt;/a&gt;Authorization Request&lt;/h3&gt;&lt;p&gt;在 Authorization Code Grant 或者 Implicit Grant 的授权模式中，授权服务都需要提供一个 HTTP 页面，用于用户向第三方应用授权。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务必须在该页面验证用户的身份。具体的认证方式（如 password、session cookie 等）不在本标准的讨论范围中。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;授权请求参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;response_type - 必须。&lt;code&gt;code&lt;/code&gt; 或 &lt;code&gt;token&lt;/code&gt;，分别表示 Authorization Code Grant 和 Implicit Grant。&lt;/li&gt;
&lt;li&gt;client_id - 必须。应用唯一标识。&lt;/li&gt;
&lt;li&gt;redirect_uri - 可选。（仅当 client 注册了唯一的完整回调地址时可不传）&lt;/li&gt;
&lt;li&gt;scope - 可选。&lt;/li&gt;
&lt;li&gt;state - 推荐。用来维持请求方状态的参数，无论授权成功与否，返回时都会原封不动地带上这个参数。。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：若请求中没有携带必须参数，或传入了不合法的值，授权服务必须向用户展示错误提示，禁止自动跳转到回调地址去。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight perl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET /authorize?response_type=code&amp;amp;client_id=s6BhdRkqt3&amp;amp;&lt;span class=&quot;keyword&quot;&gt;state&lt;/span&gt;=xyz&amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Host: server.example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Authorization-Response&quot;&gt;&lt;a href=&quot;#Authorization-Response&quot; class=&quot;headerlink&quot; title=&quot;Authorization Response&quot;&gt;&lt;/a&gt;Authorization Response&lt;/h3&gt;&lt;p&gt;在 Authorization Code Grant 授权模式中，授权服务向 client 返回 authorization code 的响应。&lt;/p&gt;
&lt;p&gt;正常响应参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;code - Authorization Code&lt;/li&gt;
&lt;li&gt;state - 如果请求参数中有，需要原封不对地返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight pf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;302&lt;/span&gt; Found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;amp;&lt;span class=&quot;keyword&quot;&gt;state&lt;/span&gt;=xyz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误响应参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error - 必须。错误码&lt;/li&gt;
&lt;li&gt;error_description - 可选。错误描述&lt;/li&gt;
&lt;li&gt;error_uri - 可选。&lt;/li&gt;
&lt;li&gt;state - 如果请求参数中有，需要原封不对地返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/1.1 &lt;span class=&quot;number&quot;&gt;302&lt;/span&gt; Found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Location&lt;/span&gt;: https://client.example.com/cb?error=access_denied&amp;amp;state=xyz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Access-Token-Request&quot;&gt;&lt;a href=&quot;#Access-Token-Request&quot; class=&quot;headerlink&quot; title=&quot;Access Token Request&quot;&gt;&lt;/a&gt;Access Token Request&lt;/h3&gt;&lt;p&gt;在 Authorization Code Grant 授权模式中，client 调用 Access Token Request 用 authorization code 换取 access token。&lt;/p&gt;
&lt;p&gt;而在 Resource Owner Password Credentials Grant 或者 Client Credentials Grant 的授权模式中，client 都是直接调用 Access Token Request 来获取 Access Token，无需用户授权。&lt;/p&gt;
&lt;p&gt;client 发起请求时，授权服务必须验证 client 的身份。client 身份用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强制校验 refresh_token 或 authorization code 绑定的 client&lt;/li&gt;
&lt;li&gt;便于单方面收回某个已经不安全的 client 的权限&lt;/li&gt;
&lt;li&gt;便于周期性的更新 client 认证信息，有效防止 client 认证信息被盗取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请求参数（Authorization Code Grant）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grant_type - 必须。值为&lt;code&gt;authorization_code&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;code -&lt;/li&gt;
&lt;li&gt;redirect_uri -&lt;/li&gt;
&lt;li&gt;client_id - 如果授权服务没有验证 client 的身份，则该项必填。&lt;/li&gt;
&lt;li&gt;scope - 请求的资源范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请求参数（Resource Owner Password Credentials Grant）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grant_type - 必须。值为&lt;code&gt;password&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;username -&lt;/li&gt;
&lt;li&gt;password -&lt;/li&gt;
&lt;li&gt;scope - 请求的资源范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请求参数（Client Credentials Grant）（身份认证信息在 HTTP BA 认证 header 中）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grant_type - 必须。值为&lt;code&gt;client_credentials&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;scope - 请求的资源范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/token&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Host&lt;/span&gt;: server.example.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Authorization&lt;/span&gt;: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW （第三方应用身份认证）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Type&lt;/span&gt;: application/x-www-form-urlencoded&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;apache&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;grant_type&lt;/span&gt;=authorization_code&amp;amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;amp;redirect_uri=https&lt;span class=&quot;number&quot;&gt;%3&lt;/span&gt;A&lt;span class=&quot;number&quot;&gt;%2&lt;/span&gt;F&lt;span class=&quot;number&quot;&gt;%2&lt;/span&gt;Fclient&lt;span class=&quot;number&quot;&gt;%2&lt;/span&gt;Eexample&lt;span class=&quot;number&quot;&gt;%2&lt;/span&gt;Ecom&lt;span class=&quot;number&quot;&gt;%2&lt;/span&gt;Fcb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Access-Token-Response&quot;&gt;&lt;a href=&quot;#Access-Token-Response&quot; class=&quot;headerlink&quot; title=&quot;Access Token Response&quot;&gt;&lt;/a&gt;Access Token Response&lt;/h3&gt;&lt;p&gt;四种授权模式中，授权服务向 client 返回 access token 的响应。&lt;/p&gt;
&lt;p&gt;响应参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;access_token - access token&lt;/li&gt;
&lt;li&gt;token_type - access token 类型&lt;/li&gt;
&lt;li&gt;expires_in - access token 的过期时间&lt;/li&gt;
&lt;li&gt;refresh_token - （仅在 Authorization Code Grant 和 Resource Owner Password Credentials Grant 模式下支持）&lt;/li&gt;
&lt;li&gt;scope - access token 实际的范围（可能与请求范围不同）&lt;/li&gt;
&lt;li&gt;state - （仅用于 Implicit Grant 授权模式，对应 Authorization Request 的参数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP/1.1 &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Type&lt;/span&gt;: application/json;charset=UTF-8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Cache-Control&lt;/span&gt;: no-store&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Pragma&lt;/span&gt;: no-cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;json&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;access_token&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;2YotnFZFEjr1zCsicMWpAA&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;token_type&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;example&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;expires_in&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3600&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;refresh_token&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;scope&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;example_value&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Access-Token&quot;&gt;&lt;a href=&quot;#Access-Token&quot; class=&quot;headerlink&quot; title=&quot;Access Token&quot;&gt;&lt;/a&gt;Access Token&lt;/h2&gt;&lt;p&gt;标准中并没有规定 access token 的数据结构和算法。&lt;/p&gt;
&lt;h3 id=&quot;有效范围（Scope）&quot;&gt;&lt;a href=&quot;#有效范围（Scope）&quot; class=&quot;headerlink&quot; title=&quot;有效范围（Scope）&quot;&gt;&lt;/a&gt;有效范围（Scope）&lt;/h3&gt;&lt;p&gt;OAuth 2.0 标准只规定了 scope 的语法，并没有说明如何使用它。&lt;br&gt;&lt;figure class=&quot;highlight d&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// OAuth 2.0 使用 ABNF 范式来定义语法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// *() 指出现0次或多次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;scope&lt;/span&gt;       = &lt;span class=&quot;keyword&quot;&gt;scope&lt;/span&gt;-token *( SP &lt;span class=&quot;keyword&quot;&gt;scope&lt;/span&gt;-token )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1*() 指出现1次或多次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;scope&lt;/span&gt;-token = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*( %x21 / %x23-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;B / %x5D-&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;E )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;类型（Types）&quot;&gt;&lt;a href=&quot;#类型（Types）&quot; class=&quot;headerlink&quot; title=&quot;类型（Types）&quot;&gt;&lt;/a&gt;类型（Types）&lt;/h3&gt;&lt;p&gt;OAuth 2.0 标准中只介绍了两种 Access Token 类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“bearer” token - &lt;a href=&quot;https://tools.ietf.org/html/rfc6750&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC6750&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;“mac” token - [OAuth-HTTP-MAC] HTTP Authentication: MAC Access Authentication&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Refresh-Token&quot;&gt;&lt;a href=&quot;#Refresh-Token&quot; class=&quot;headerlink&quot; title=&quot;Refresh Token&quot;&gt;&lt;/a&gt;Refresh Token&lt;/h2&gt;&lt;p&gt;通常 refresh token 是一个长时间有效（相比较 access token 的有效期）的凭证，应用可以使用 refresh token 来换取一个新的 access token（即使原 access token 已过期）。&lt;/p&gt;
&lt;p&gt;授权服务刷新 access token 前的校验步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证 client 的身份&lt;/li&gt;
&lt;li&gt;验证 refresh token 与 client 的绑定关系&lt;/li&gt;
&lt;li&gt;验证 refresh token 的合法性&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：刷新 access token 时，授权服务也可以返回新的 refresh token。在这种情况下，client 必须丢弃掉旧的 refresh token；且新的 refresh token 的 scope 必须与原 refresh token 保持一致。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：安全起见，refresh token 需要与 client 绑定。并且授权服务需要验证 client 的身份。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：当授权服务返回一个新的 refresh token 时，可以选择将旧 token 置为失效。&lt;/p&gt;&lt;/div&gt;
&lt;h2 id=&quot;访问资源&quot;&gt;&lt;a href=&quot;#访问资源&quot; class=&quot;headerlink&quot; title=&quot;访问资源&quot;&gt;&lt;/a&gt;访问资源&lt;/h2&gt;&lt;p&gt;资源服务响应资源访问请求前的校验步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;校验 access token 的合法性&lt;/li&gt;
&lt;li&gt;校验 access token 是否过期&lt;/li&gt;
&lt;li&gt;校验 access token 的 scope 范围是否包括该资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;资源服务校验 access token 的方式不在标准的讨论范围中。&lt;/p&gt;
&lt;h2 id=&quot;安全性考虑（Security-Considerations）&quot;&gt;&lt;a href=&quot;#安全性考虑（Security-Considerations）&quot; class=&quot;headerlink&quot; title=&quot;安全性考虑（Security Considerations）&quot;&gt;&lt;/a&gt;安全性考虑（Security Considerations）&lt;/h2&gt;&lt;p&gt;标准中列出了一些实现 OAuth 2.0 时需要注意的安全问题。更全面的安全模型和分析，包括协议涉及的背景，在另一篇标准 RFC 6819 中。&lt;/p&gt;
&lt;h3 id=&quot;应用身份认证和伪造&quot;&gt;&lt;a href=&quot;#应用身份认证和伪造&quot; class=&quot;headerlink&quot; title=&quot;应用身份认证和伪造&quot;&gt;&lt;/a&gt;应用身份认证和伪造&lt;/h3&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;&lt;strong&gt;禁止&lt;/strong&gt;：授权服务禁止向 public client 颁发 client password 做身份认证。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：当授权服务无法验证 client 的认证时，应该使用其他方式验证 client 的授权请求。比如验证 Redirection URI，或者让用户来协助判断 client 的身份。&lt;/p&gt;
&lt;p&gt;验证 Redirection URI 对验证 client 身份实际上没有什么帮助，但它可以防止授权凭证被携带给陌生的 client。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：授权服务应该向用户提供 client 的信息（如应用名称、logo等）、client 想申请的授权范围（scope），以及授权的有效时间；用户根据这些信息来决定是否授予 client 权限。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;strong&gt;不推荐&lt;/strong&gt;：授权服务不应该未经用户交互或 client 的身份认证就自动处理授权请求。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;Access-Token-安全&quot;&gt;&lt;a href=&quot;#Access-Token-安全&quot; class=&quot;headerlink&quot; title=&quot;Access Token 安全&quot;&gt;&lt;/a&gt;Access Token 安全&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：access token 只能在授权服务、资源服务和对应的 client 之间传输和存储，且传输通道必须使用 TLS。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;当使用 Implicit Grant Type 时，access token 在 URI 的 Fragment 中传输，可以避免暴露给未授权的第三方（如不可信网络或运营商）。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务必须保证 access token 无法被未授权的第三方伪造或篡改。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;Refresh-Token-安全&quot;&gt;&lt;a href=&quot;#Refresh-Token-安全&quot; class=&quot;headerlink&quot; title=&quot;Refresh Token 安全&quot;&gt;&lt;/a&gt;Refresh Token 安全&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：refresh token 只能在授权服务和对应的 client 之间传输和存储，且传输通道必须使用 TLS。授权服务必须维护和验证 refresh token 和 client 的绑定关系。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务必须保证 refresh token 无法被未授权的第三方伪造或篡改。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;Authorization-Code-安全&quot;&gt;&lt;a href=&quot;#Authorization-Code-安全&quot; class=&quot;headerlink&quot; title=&quot;Authorization Code 安全&quot;&gt;&lt;/a&gt;Authorization Code 安全&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：authorization code 的传输通道必须使用 TLS。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：authorization code 的有效期必须是短暂的，且只能使用一次。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：如果授权服务发现同一个 authorization code 多次尝试请求 access token，应该把之前该 authorization code 换取的 access token 置为失效。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;Redirection-URI-篡改攻击&quot;&gt;&lt;a href=&quot;#Redirection-URI-篡改攻击&quot; class=&quot;headerlink&quot; title=&quot;Redirection URI 篡改攻击&quot;&gt;&lt;/a&gt;Redirection URI 篡改攻击&lt;/h3&gt;&lt;p&gt;假如现在有一个正常授权请求：&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/authorize?response_type=code&amp;amp;client_id=s6BhdRkqt3&amp;amp;redirect_uri=https://client.normal.com&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Host&lt;/span&gt;: server.example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在攻击者篡改其中的 redirect_uri，变成下面的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/authorize?response_type=code&amp;amp;client_id=s6BhdRkqt3&amp;amp;redirect_uri=https://client.attack.com&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Host&lt;/span&gt;: server.example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后攻击者把这个 URL 提供给用户。用户如果没注意，同意了授权的话，则攻击者（&lt;a href=&quot;https://client.attack.com）就会收到&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://client.attack.com）就会收到&lt;/a&gt; authorization code。&lt;/p&gt;
&lt;p&gt;然后攻击者带着这个 authorization code 访问正常 client 的 redirect_uri。一般情况下，client 会拿着 authorization code 向授权服务换取 access token。这样攻击者就可以拿到用户的 authorization code 了。&lt;/p&gt;
&lt;p&gt;（为什么攻击者不能直接拿 authorization code 换 access token 呢？—— 因为 access token request 带有 client 身份认证，如 HTTP BA认证 ）&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务需要校验请求 authorization code 的 Redirection URI 与该 authorization code 请求 access token 时的 Redirection URI 是否一致。&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务必须要求 public client 在注册时提供 Redirection URIs，confidential client 可选但有则更好。授权服务必须校验每个请求（包括 Authorization Request 和 Access Token Request）中 redirect_uri。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;中间人攻击&quot;&gt;&lt;a href=&quot;#中间人攻击&quot; class=&quot;headerlink&quot; title=&quot;中间人攻击&quot;&gt;&lt;/a&gt;中间人攻击&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：为了避免中间人攻击，授权服务提供的 API 或者页面都必须使用 TLS。client 必须校验授权服务的 TLS 证书。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;穷举攻击&quot;&gt;&lt;a href=&quot;#穷举攻击&quot; class=&quot;headerlink&quot; title=&quot;穷举攻击&quot;&gt;&lt;/a&gt;穷举攻击&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务必须保证 access token, refresh token, authorization code, 用户密码, 应用的身份信息不能被穷举攻击。其被攻击到的概率&lt;strong&gt;必须&lt;/strong&gt;小于 2^(-128)，&lt;strong&gt;推荐&lt;/strong&gt;小于2^(-160)。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;CSRF-攻击&quot;&gt;&lt;a href=&quot;#CSRF-攻击&quot; class=&quot;headerlink&quot; title=&quot;CSRF 攻击&quot;&gt;&lt;/a&gt;CSRF 攻击&lt;/h3&gt;&lt;h4 id=&quot;on-Redirection-URI&quot;&gt;&lt;a href=&quot;#on-Redirection-URI&quot; class=&quot;headerlink&quot; title=&quot;on Redirection URI&quot;&gt;&lt;/a&gt;on Redirection URI&lt;/h4&gt;&lt;p&gt;攻击者可以利用 CSRF 攻击，在正常用户的 user agent 上请求 client 的 Redirection URI ，并带上自己的 authorization code 或者 access token 。这样正常用户之前的授权状态就会被覆盖，在不知情的情况下，做一些危险的操作（如转账、设置管理员权限等）。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：client 的 Redirection URI 必须能够防止 CSRF 攻击；推荐 client 在发起授权请求时使用 OAuth 2.0 中的 state 参数。&lt;/p&gt;&lt;/div&gt;
&lt;h4 id=&quot;on-Authorization-Request&quot;&gt;&lt;a href=&quot;#on-Authorization-Request&quot; class=&quot;headerlink&quot; title=&quot;on Authorization Request&quot;&gt;&lt;/a&gt;on Authorization Request&lt;/h4&gt;&lt;p&gt;通常，授权服务的 Authorization Request 是一个用户交互页面。如果该页面提交授权的请求没有防 CSRF，那么攻击者就可以在用户不知情的情况下（构造表单自动提交）让用户授权给一个恶意的 client 或者 Redirection URI。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务提供的授权页面必须能够防止 CSRF 攻击，并且对于无法确认身份的 client（如 public client）需要在交互页面提醒用户。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;点击劫持攻击&quot;&gt;&lt;a href=&quot;#点击劫持攻击&quot; class=&quot;headerlink&quot; title=&quot;点击劫持攻击&quot;&gt;&lt;/a&gt;点击劫持攻击&lt;/h3&gt;&lt;p&gt;攻击者可以实现一个伪造的页面（如钓鱼网站），在页面之下隐藏着一个授权服务提供的授权页面（设置用户不可见，但按钮可以点击）。用户可能在不知情的情况下，授权给某个无法确认身份的恶意 client。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务提供的授权页面必须能够防止点击劫持攻击。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;代码注入攻击&quot;&gt;&lt;a href=&quot;#代码注入攻击&quot; class=&quot;headerlink&quot; title=&quot;代码注入攻击&quot;&gt;&lt;/a&gt;代码注入攻击&lt;/h3&gt;&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;&lt;strong&gt;强制&lt;/strong&gt;：授权服务和 client 必须忽略任何标准中（或双方的对接文档中）未提到的参数；并且需要校验每一个有效参数的合法性。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;Open-Redirector&quot;&gt;&lt;a href=&quot;#Open-Redirector&quot; class=&quot;headerlink&quot; title=&quot;Open Redirector&quot;&gt;&lt;/a&gt;Open Redirector&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Open Redirectors&lt;/code&gt; 表示一类 HTTP 请求，它接受一个 redirect_uri，或者 continue 之类的参数，没有经过验证（或仅验证了部分），然后 location 到 redirect uri 中。&lt;/p&gt;
&lt;p&gt;Open Redirectors 很容易导致攻击者伪造一个自己可以控制的 URI，然后获取到授权信息。&lt;/p&gt;
&lt;p&gt;前面提到过，client 在向授权服务注册时，Redirection URI 部分是有限制的，就是为了防止这个。&lt;/p&gt;
&lt;h2 id=&quot;移动应用（Native-Applications）&quot;&gt;&lt;a href=&quot;#移动应用（Native-Applications）&quot; class=&quot;headerlink&quot; title=&quot;移动应用（Native Applications）&quot;&gt;&lt;/a&gt;移动应用（Native Applications）&lt;/h2&gt;&lt;p&gt;（待补充）&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://oauth.net/2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OAuth 2.0 主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6749&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 6749 - The OAuth 2.0 Authorization Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6819&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 6819 - OAuth 2.0 Threat Model and Security Considerations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7521&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 7521 - Assertion Framework for OAuth 2.0 Client Authentication and&lt;br&gt;Authorization Grants&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下业界标准的第三方应用授权框架 —— OAuth 协议。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Collections Framework</title>
    <link href="http://blog.abandonzhang.me/2017/09/05/Java-Collections-Framework/"/>
    <id>http://blog.abandonzhang.me/2017/09/05/Java-Collections-Framework/</id>
    <published>2017-09-05T14:15:13.000Z</published>
    <updated>2018-01-21T10:14:19.669Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;Java Collections Framework&lt;/code&gt; 是 Java SE 提供的&lt;code&gt;容器&lt;/code&gt;的接口定义与实现，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interfaces. 抽象的容器接口定义，如 Set、Map&lt;/li&gt;
&lt;li&gt;Implementations. 具体的容器实现，如 HashSet、TreeMap&lt;/li&gt;
&lt;li&gt;Algorithms. 对容器对象的计算和操作，如排序、查找，支持多态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java SE 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Interfaces&quot;&gt;&lt;a href=&quot;#Interfaces&quot; class=&quot;headerlink&quot; title=&quot;Interfaces&quot;&gt;&lt;/a&gt;Interfaces&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Java-Collections-Framework-Interface.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Iterable&quot;&gt;&lt;a href=&quot;#Iterable&quot; class=&quot;headerlink&quot; title=&quot;Iterable&quot;&gt;&lt;/a&gt;Iterable&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Iterable&lt;/code&gt; 不算是 Java Collections Framework 中的一员，它是定义在 java.lang 包中的一个基础的接口，所有实现该接口的类都可以通过迭代器 Iterator 来遍历其中的对象。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java 语言规范&lt;/a&gt;中，仅有实现 Iterable 接口或者数组类型的对象能以 &lt;code&gt;enhanced for statement&lt;/code&gt; （for-each）的方式遍历，否则会在编译时报错。&lt;/p&gt;
&lt;p&gt;Iterable 中定义了方法 iterator(), 返回可以迭代该对象的 Iterator；&lt;/p&gt;
&lt;p&gt;在 Java 1.8 中，Iterable 又加入了一个 default 方法 forEach() 来支持函数式编程的 for-each 循环，以及一个 default 方法 spliterator()，返回可以并行迭代对象的迭代器 Spliterator，这里不多做介绍了。&lt;/p&gt;
&lt;h4 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 是除 Map 族以外所有容器的基类，仅表示存放一组对象的&lt;code&gt;容器&lt;/code&gt;。在 Collection 的定义中，元素可以是重复的，也可以是不重复的；可以是排序的，也可以是不排序的；取决于具体的子类或实现。注意它与数学中的&lt;code&gt;集合&lt;/code&gt;概念的区别。&lt;/p&gt;
&lt;p&gt;Collection 中定义了一些所有容器通用的基本操作：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Collection&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Iterator&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Object[] toArray();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; T[] toArray(T[] a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;containsAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? extends E&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// @since 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeIf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Predicate&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; E&amp;gt; filter)&lt;/span&gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;retainAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object o)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// @since 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Spliterator&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;spliterator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// @since 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Stream&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// @since 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Stream&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;parallelStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;JDK 中没有提供直接实现 Collection 接口的类，而是在其基础上又继承出一些子接口，如：Set、List、Queue 等。而在这些子接口中，我们没有看到描述一组无序且允许重复的对象的集合 —— MultiSet 。&lt;/p&gt;
&lt;p&gt;在 JDK Bug System (JBS) 列表中，&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6567419&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JDK-6567419&lt;/a&gt; 提到了这点，评论有说是 MultiSet、MultiMap 使用场景不是很多，The Collections Framework 的作者们没什么热情做。。。&lt;/p&gt;
&lt;p&gt;抛开 JDK 本身， &lt;a href=&quot;https://github.com/google/guava/wiki/NewCollectionTypesExplained&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Guava&lt;/a&gt; 和 &lt;a href=&quot;https://commons.apache.org/proper/commons-collections/javadocs/api-release/org/apache/commons/collections4/package-summary.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache Commons&lt;/a&gt; 这两个著名的 Collections 第三方扩展包中均实现了这个数据结构。其接口直接继承了 Collection，与 Set、List 等接口在同一层级。这个在 JDK 的 Collection 接口说明中也有提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h4&gt;&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 在中文里一般叫做&lt;code&gt;列表&lt;/code&gt;，其描述一组有序的元素，直接继承了 Collection 接口。与 Collection 接口相比，List 并没有其他的新增方法定义，也仅仅只是重新定义了一遍。&lt;/p&gt;
&lt;h4 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; class=&quot;headerlink&quot; title=&quot;Set&quot;&gt;&lt;/a&gt;Set&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; 与数学中的&lt;code&gt;集合&lt;/code&gt;概念更贴近，其描述一组不可重复的元素，直接继承了 Collection 接口。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java Collections Framework&lt;/code&gt; 是 Java SE 提供的&lt;code&gt;容器&lt;/code&gt;的接口定义与实现，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interfaces. 抽象的容器接口定义，如 Set、Map&lt;/li&gt;
&lt;li&gt;Implementations. 具体的容器实现，如 HashSet、TreeMap&lt;/li&gt;
&lt;li&gt;Algorithms. 对容器对象的计算和操作，如排序、查找，支持多态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html&quot;&gt;Java SE 官方文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代理模式和 Java 动态代理</title>
    <link href="http://blog.abandonzhang.me/2017/07/30/Proxy-Pattern-And-Java-Dynamic-Proxy/"/>
    <id>http://blog.abandonzhang.me/2017/07/30/Proxy-Pattern-And-Java-Dynamic-Proxy/</id>
    <published>2017-07-30T06:53:26.000Z</published>
    <updated>2018-01-21T10:14:19.676Z</updated>
    
    <content type="html">&lt;p&gt;要弄清楚动态代理，首先需要明白什么是代理，以及什么是静态代理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;代理是间接访问目标对象的一种模式。&lt;/p&gt;
&lt;p&gt;代理有什么好处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对调用方而言，代理可以屏蔽掉目标对象的构造和与之通信的具体实现细节，仅关注自己需要关注的部分（如配置、输入参数、输出结果等）&lt;/li&gt;
&lt;li&gt;对目标对象而言，代理可以帮助目标对象做一些权限控制、日志统计等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;UML-类图&quot;&gt;&lt;a href=&quot;#UML-类图&quot; class=&quot;headerlink&quot; title=&quot;UML 类图&quot;&gt;&lt;/a&gt;UML 类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在代理模式中有三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Subject：目标类的接口（或抽象类）&lt;/li&gt;
&lt;li&gt;RealSubject：目标类&lt;/li&gt;
&lt;li&gt;Proxy：代理类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在面向接口编程中，Proxy 实现了 Subject 接口，使其对于 Client 而言与 RealSubject 是一样的，Proxy 类中会保存真正的目标对象 realSubject ，然后在它的构造函数中封装 realSubject 的构造细节，在它的方法中封装 realSubject 的方法细节。&lt;/p&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;&lt;a href=&quot;#静态代理&quot; class=&quot;headerlink&quot; title=&quot;静态代理&quot;&gt;&lt;/a&gt;静态代理&lt;/h2&gt;&lt;p&gt;静态代理实际就是按照代理模式把各角色类事先（编译前）都定义好。如下代码：&lt;/p&gt;
&lt;p&gt;Subject&lt;br&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Subject&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;RealSubject&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RealSubject&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Subject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;This is RealSubject request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Proxy&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Subject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; RealSubject realSubject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Proxy &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 隐藏 RealSubject 的构造细节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Proxy proxy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Proxy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RealSubject realSubject = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RealSubject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy.realSubject = realSubject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; proxy;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Log before and after real process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Before RealSubject request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        realSubject.request();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;After RealSubject request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Client&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Client&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; request(Subject subject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Proxy is same with RealSubject for Client, they are all Subject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subject-&amp;gt;request();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with RealSubject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;Client&lt;/span&gt;.request(new RealSubject());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with Proxy &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;Client&lt;/span&gt;.request(Proxy.getInstance());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;静态代理有个明显的缺点：随着需要代理的目标类越来越多，或目标类的方法越来越多，Proxy 的代码越来越难以维护。每次新增或者修改目标类的代码，对应的 Proxy 的代码也需要跟着改。&lt;/p&gt;
&lt;p&gt;动态代理的意思就是，Proxy 类是在运行期生成的，不需要在编译前就把它的代码设计出来，这样我们就不需要关心 Proxy 类的复杂性了。&lt;/p&gt;
&lt;p&gt;Java 中的动态代理有 JDK 动态代理和 cglib 动态代理两种，下面分别来说一下。&lt;/p&gt;
&lt;h3 id=&quot;JDK-动态代理&quot;&gt;&lt;a href=&quot;#JDK-动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK 动态代理&quot;&gt;&lt;/a&gt;JDK 动态代理&lt;/h3&gt;&lt;p&gt;JDK 动态代理中的各角色如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86UML%E5%9B%BE&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来分析一下 JDK 动态代理中新增的这些角色的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Proxy$xxx：之所以是这样一个奇怪的类名，是因为这个类名是 JDK 自动生成的，我们不需要自己设计和编写每个 Proxy 类的代码&lt;/li&gt;
&lt;li&gt;Proxy：既是所有 JDK 动态代理类的基类，又是一个工具类，向用户提供获取动态代理类的方法&lt;/li&gt;
&lt;li&gt;InvocationHandler：动态代理执行时的回调处理接口。每个 JDK 动态代理执行方法时都是调用 InvocationHandler 的 invoke 方法处理具体逻辑&lt;/li&gt;
&lt;li&gt;MyInvocationHandler：用户自定义的 InvocationHandler 的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h4&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt; newProxyInstance(ClassLoader loader,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;[] interfaces,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      InvocationHandler h)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    throws IllegalArgumentException&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JDK 动态代理类的生成由 Proxy.newProxyInstance 方法实现。方法接受三个参数：ClassLoader 、 interfaces 和 InvocationHandler 的实例。&lt;/p&gt;
&lt;p&gt;下面看一下具体在代码中如何使用它。&lt;/p&gt;
&lt;p&gt;跟静态代理相比，我们的 Subject 和 RealSubject 都没有变化。有变化的是，原来我们需要自己设计 Proxy 类，现在我们需要自己设计 InvocationHandler 类，Client 的相应处理也有些许变化。&lt;/p&gt;
&lt;p&gt;在这里可能看不出实现 Proxy 类和实现 MyInvocationHandler 类有什么区别；不过当你要代理的类很多时，你就能体会到显著的区别了。&lt;/p&gt;
&lt;p&gt;MyInvocationHandler&lt;br&gt;&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class &lt;span class=&quot;type&quot;&gt;MyInvocatioHandler&lt;/span&gt; implements &lt;span class=&quot;type&quot;&gt;InvocationHandler&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private &lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt; target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public &lt;span class=&quot;type&quot;&gt;MyInvocatioHandler&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt; target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.target = target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;type&quot;&gt;Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public &lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt; invoke(&lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt; proxy, &lt;span class=&quot;type&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt;[] args) throws &lt;span class=&quot;type&quot;&gt;Throwable&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // &lt;span class=&quot;type&quot;&gt;Log&lt;/span&gt; before &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; after real process&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;string&quot;&gt;&quot;Before request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt;.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;string&quot;&gt;&quot;After request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Client&lt;br&gt;&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Client&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Subject subject)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Proxy is same with RealSubject for Client, they are all Subject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subject-&amp;gt;request();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RealSubject realSubject = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RealSubject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with RealSubject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Client.request(realSubject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with Proxy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ClassLoader loader = Thread.currentThread().getContextClassLoader();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt;[] interfaces = realSubject.getClass().getInterfaces();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InvocationHandler &lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyInvocatioHandler(realSubject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Client.request(Proxy.newProxyInstance(loader, interfaces, &lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h4&gt;&lt;p&gt;Proxy.newProxyInstance 中的核心实现是：&lt;br&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Look up or generate the designated proxy class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; &lt;span class=&quot;keyword&quot;&gt;cl&lt;/span&gt; = getProxyClass0(loader, intfs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;final Constructor&amp;lt;?&amp;gt; &lt;span class=&quot;keyword&quot;&gt;cons&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;cl&lt;/span&gt;.getConstructor(constructorParams);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;cons&lt;/span&gt;.newInstance(new Object[]&amp;#123;&lt;span class=&quot;keyword&quot;&gt;h&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;第一步：生成和加载动态代理类&quot;&gt;&lt;a href=&quot;#第一步：生成和加载动态代理类&quot; class=&quot;headerlink&quot; title=&quot;第一步：生成和加载动态代理类&quot;&gt;&lt;/a&gt;第一步：生成和加载动态代理类&lt;/h5&gt;&lt;p&gt;Proxy.getProxyClass0() 方法通过 WeakCache 对象来缓存全局的代理类的 Class，并向 WeakCache 提供了一个 ProxyClassFactory 的工厂方法。当在 WeakCache 中找不到时，就会调用 ProxyClassFactory 中真正的生成方法，然后缓存到 WeakCache 中。&lt;/p&gt;
&lt;p&gt;ProxyClassFactory 生成代理类的过程：&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; ProxyClassFactory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; BiFunction&amp;lt;ClassLoader, &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;[], &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; apply(ClassLoader loader, &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt;[] interfaces) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 校验 interfaces 是否都是接口；是否能被 ClassLoader 加载；是否有重复&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将代理类访问标记设为 public final&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; accessFlags = Modifier.&lt;span class=&quot;keyword&quot;&gt;PUBLIC&lt;/span&gt; | Modifier.&lt;span class=&quot;keyword&quot;&gt;FINAL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 校验所有 non-public 的接口是否都在一个 package&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将代理类的 package 设为这些 non-public 接口所在的 package&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果没有 non-public 的接口，则将代理类的 package 设为 com.sun.proxy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 生成代理类名称（包括完整的包路径）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 生成代理类的字节码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] proxyClassFile = ProxyGenerator.generateProxyClass(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            proxyName, interfaces, accessFlags);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 加载字节码到 JVM 中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; defineClass0(loader, proxyName, proxyClassFile, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, proxyClassFile.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassFormatError e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(e.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&quot;第二步：构造新实例，传入回调接口&quot;&gt;&lt;a href=&quot;#第二步：构造新实例，传入回调接口&quot; class=&quot;headerlink&quot; title=&quot;第二步：构造新实例，传入回调接口&quot;&gt;&lt;/a&gt;第二步：构造新实例，传入回调接口&lt;/h5&gt;&lt;p&gt;获取到代理类的 Class 对象之后，就可以获取它的 Constructor，然后通过 Constructor 的 newInstance 方法调用代理类的构造函数，将 InvocationHandler 实例传给代理类，最后将生成的代理类实例返回给用户。&lt;/p&gt;
&lt;h4 id=&quot;反编译生成的动态代理类&quot;&gt;&lt;a href=&quot;#反编译生成的动态代理类&quot; class=&quot;headerlink&quot; title=&quot;反编译生成的动态代理类&quot;&gt;&lt;/a&gt;反编译生成的动态代理类&lt;/h4&gt;&lt;p&gt;在 ProxyGenerator.generateProxyClass() 方法中可以看到有一个静态变量 saveGeneratedFiles 可以决定生成的字节码是否要保存到磁盘中。进一步可以看到这个变量实际上就是获取了名为 “sun.misc.ProxyGenerator.saveGeneratedFiles” 的系统属性（System.getProperty）。因此我们可以把对应的 saveGeneratedFiles 置为 true，然后就可以获得代理类的 class 文件，进而可以反编译它看到生成的代理类是什么样子了。&lt;/p&gt;
&lt;p&gt;下面是一个例子：&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; $Proxy0 &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Proxy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; Subject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Method m1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Method m3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Method m0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Method m2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; $Proxy0(InvocationHandler paramInvocationHandler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(paramInvocationHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; equals(Object paramObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((&lt;span class=&quot;keyword&quot;&gt;Boolean&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.h.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, m1, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object[] &amp;#123; paramObject &amp;#125;)).booleanValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; localError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; request()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.h.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, m3, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; localError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hashCode()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((Integer)&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.h.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, m0, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)).intValue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; localError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (String)&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.h.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, m2, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; localError;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m1 = &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span class=&quot;string&quot;&gt;&quot;equals&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;[] &amp;#123; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;) &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m3 = &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;string&quot;&gt;&quot;com.demo.Subject&quot;&lt;/span&gt;).getMethod(&lt;span class=&quot;string&quot;&gt;&quot;request&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m0 = &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span class=&quot;string&quot;&gt;&quot;hashCode&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m2 = &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span class=&quot;string&quot;&gt;&quot;toString&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Class&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (NoSuchMethodException localNoSuchMethodException)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NoSuchMethodError(localNoSuchMethodException.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException localClassNotFoundException)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NoClassDefFoundError(localClassNotFoundException.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从代码中可以看到， JDK 动态代理根据反射来定位到目标类的方法，并且代理类中的每个方法都是代理给 InvocationHandler 的 invoke 方法去执行。 &lt;/p&gt;
&lt;h4 id=&quot;局限&quot;&gt;&lt;a href=&quot;#局限&quot; class=&quot;headerlink&quot; title=&quot;局限&quot;&gt;&lt;/a&gt;局限&lt;/h4&gt;&lt;p&gt;由于 JDK 动态代理中是根据 interface 来生成类字节码的，因此那些没有实现接口的类或类其中的方法就无法通过 JDK 动态代理访问到。&lt;/p&gt;
&lt;h3 id=&quot;cglib-动态代理&quot;&gt;&lt;a href=&quot;#cglib-动态代理&quot; class=&quot;headerlink&quot; title=&quot;cglib 动态代理&quot;&gt;&lt;/a&gt;cglib 动态代理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cglib&lt;/a&gt; 是一个第三方的动态代理类生成工具。并且 cglib 并不限制被代理的目标类必须实现接口，这对 JDK 动态代理类是一个很好的补充。&lt;/p&gt;
&lt;p&gt;Spring AOP 中便是默认对有实现接口的类使用 JDK 动态代理，对没有实现接口的类使用 cglib 动态代理。&lt;/p&gt;
&lt;h4 id=&quot;使用方法-1&quot;&gt;&lt;a href=&quot;#使用方法-1&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h4&gt;&lt;p&gt;与 JDK 动态代理的核心类 &lt;code&gt;Proxy&lt;/code&gt; 一样， cglib 动态代理也有个核心类： &lt;code&gt;Enhancer&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;Enhancer 中创建动态代理的方法是 create ，但在调用这个方法之前，必须先通过 setSuperclass 和 setCallback 设置被代理的目标类和代理时的回调类（类似 JDK 动态代理的 InvocationHandler ）。&lt;/p&gt;
&lt;p&gt;cglib 中定义了6种回调类，它们都实现了 cglib 中的 Callback 接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InvocationHandler&lt;/li&gt;
&lt;li&gt;MethodInterceptor&lt;/li&gt;
&lt;li&gt;FixedValue&lt;/li&gt;
&lt;li&gt;LazyLoader&lt;/li&gt;
&lt;li&gt;Dispatcher&lt;/li&gt;
&lt;li&gt;NoOp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InvocationHandler 和 JDK 动态代理中的 InvocationHandler 使用方法几乎一模一样。如果我们要在代理时调用到目标类的方法，就必须自己在构造 InvocationHandler 时把目标类对象保存进来。另外也要注意调用 method.invoke 时一定传的是原始的目标类对象，而不是 proxy 对象，否则会陷入无限递归调用中。&lt;/p&gt;
&lt;p&gt;MethodInterceptor 是 cglib 中对 InvocationHandler 增强的一个回调类。它会在接口方法中将原目标类的一个对象传给我们，并且通过 proxy.invokeSuper() 方法可以直接调用目标类对象的对应方法。&lt;/p&gt;
&lt;p&gt;后面几个暂时先不提了，后面再补充。&lt;/p&gt;
&lt;p&gt;通过 MethodInterceptor 和匿名函数，我们可以非常简单的实现上面的 realSubject 的代理，连定义 MyInvocationHandler 类也不需要了。&lt;br&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Client&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;RealSubject realSubject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        realSubject-&amp;gt;request();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;String[] args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RealSubject realSubject = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RealSubject();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with RealSubject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Client.request(realSubject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Client communicate with Proxy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Enhancer enhancer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Enhancer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        enhancer.setSuperclass(RealSubject.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        enhancer.setCallback(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MethodInterceptor() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;intercept&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Object obj, Method method, Object[] args, MethodProxy proxy&lt;/span&gt;) throws Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.&lt;span class=&quot;keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;string&quot;&gt;&quot;Before request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Object &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; = proxy.invokeSuper(obj, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.&lt;span class=&quot;keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;string&quot;&gt;&quot;After request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Client.request((RealSubject) enhancer.create());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;未完待续&quot;&gt;&lt;a href=&quot;#未完待续&quot; class=&quot;headerlink&quot; title=&quot;未完待续&quot;&gt;&lt;/a&gt;未完待续&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;要弄清楚动态代理，首先需要明白什么是代理，以及什么是静态代理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
      <category term="设计模式" scheme="http://blog.abandonzhang.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池</title>
    <link href="http://blog.abandonzhang.me/2017/05/13/Java-ThreadPool/"/>
    <id>http://blog.abandonzhang.me/2017/05/13/Java-ThreadPool/</id>
    <published>2017-05-13T10:08:13.000Z</published>
    <updated>2018-01-21T10:14:19.677Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Runnable&quot;&gt;&lt;a href=&quot;#Runnable&quot; class=&quot;headerlink&quot; title=&quot;Runnable&quot;&gt;&lt;/a&gt;Runnable&lt;/h2&gt;&lt;p&gt;Runnable 是 java.lang 包中定义的接口，表示一个可被线程执行的类。接口定义了一个 run() 方法来指定线程执行的动作。从现实世界角度讲，Runnable 就像一个任务。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerlink&quot; title=&quot;Thread&quot;&gt;&lt;/a&gt;Thread&lt;/h2&gt;&lt;p&gt;Thread 是 java.lang 中定义的类，它是线程在 Java 世界中的表示。Thread 有很多成员变量和方法来描述线程的属性和行为，如 priority 表示线程的优先级，tid 表示线程 ID，threadStatus 变量和 State 枚举类型表示线程的状态等。&lt;/p&gt;
&lt;p&gt;众所周知，有两种创建一个新线程并执行一个任务的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承 Thread 类，重写 run() 方法。new MyThread().start()&lt;/li&gt;
&lt;li&gt;实现 Runnable 接口和 run() 方法。new Thread(MyRunnable).start()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而第一种方式是不被推荐的，原因不再赘述。&lt;/p&gt;
&lt;p&gt;真正创建一个新线程是调用 Thread 对象的 start() 方法，同时 JVM 会调用 run() 方法来执行线程的动作。单独调用 Thread 的 run() 方法不会创建一个新线程，而是在当前线程中执行任务。&lt;/p&gt;
&lt;p&gt;让我感到困惑的是，为什么 Thread 要实现 Runnable 接口和它的 run() 方法。从面向对象的角度讲，Thread 是一个线程，是执行任务的载体，而不应该是任务本身。&lt;a href=&quot;http://stackoverflow.com/questions/18305953/why-does-thread-implement-runnable&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;同样有人感到了困惑并且提出了问题，从回答来看，这是一个兼容历史代码的不得已而为之。&lt;/p&gt;
&lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;Callable 是 java.util.concurrent 包中定义的接口，与 Runnable 类似，表示一个可被线程执行的类。与 Runnable 不同的是，Callable 定义了一个有泛型返回值的方法 call()，即 Callable 是一个需要知道执行结果的任务。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;V &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Executor&quot;&gt;&lt;a href=&quot;#Executor&quot; class=&quot;headerlink&quot; title=&quot;Executor&quot;&gt;&lt;/a&gt;Executor&lt;/h2&gt;&lt;p&gt;Executor 是 java.util.concurrent 包中定义的接口，表示一个任务调度器，可以执行一些任务（Runnable）。它定义了一个 execute() 方法，提交一个任务，然后决定在某一时刻以某种方式去执行这个任务。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Executes the given command at some time in the future.  The command&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * may execute in a new thread, in a pooled thread, or in the calling&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * thread, at the discretion of the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; Executor&amp;#125; implementation.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; command the runnable task&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; RejectedExecutionException if this task cannot be&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * accepted for execution&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; NullPointerException if command is null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;ExecutorService&quot;&gt;&lt;a href=&quot;#ExecutorService&quot; class=&quot;headerlink&quot; title=&quot;ExecutorService&quot;&gt;&lt;/a&gt;ExecutorService&lt;/h2&gt;&lt;p&gt;Executor 是一个简单粗暴的调度器接口，只能提交一个无法获取执行结果的任务，也没有办法控制调度器的状态。&lt;/p&gt;
&lt;p&gt;java.util.concurrent 包又定义了一个继承 Executor 的接口 ExecutorService，一个更加完善的任务调度器框架，提供更丰富的任务提交方式以及调度器的生命周期管理。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;Runnable&amp;gt; shutdownNow();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isShutdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isTerminated&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;invokeAny&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;invokeAny&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Callable&amp;lt;T&amp;gt;&amp;gt; tasks,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException, ExecutionException, TimeoutException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新增的方法 shutdown() 可以让调度器进入平缓的关闭状态，不再接受新的任务，等待已提交的任务完成后再进入终止状态；shutdownNow() 强制停止所有任务，直接进入终止状态。新增的多个重载的 submit() 方法可以提交 Runnable 和 Callable 任务，并且获取任务的执行结果。&lt;/p&gt;
&lt;h2 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;终于轮到了我们的主角 ThreadPoolExecutor ：基于线程池的多线程任务调度器。ThreadPoolExecutor 类定义在 java.util.concurrent 包中，实现了 ExecutorService 接口。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractExecutorService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 先省略 **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从源码中看 ThreadPoolExecutor 是继承了一个 AbstractExecutorService ，并不是实现了 ExecutorService 接口呀？&lt;/p&gt;
&lt;p&gt;实际上 AbstractExecutorService 就是一个抽象的 ExecutorService 类，它封装了一些通用的实现，这样在具体的 ExecutorService 类中只需要关心其他的具体逻辑就可以了。如 ThreadPoolExecutor 就不需要实现 submit() 方法，只关注和实现了最核心的 execute() 方法。&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;p&gt;下面我们就来看看如何创建一个 ThreadPoolExecutor 。&lt;/p&gt;
&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              TimeUnit unit,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              ThreadFactory threadFactory,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              RejectedExecutionHandler &lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt; corePoolSize ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keepAliveTime &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt; == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.corePoolSize = corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maximumPoolSize = maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.workQueue = workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keepAliveTime = unit.toNanos(keepAliveTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.threadFactory = threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;handler&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize 线程池的核心线程数&lt;br&gt;提交一个新任务时，如果线程池中的线程少于 corePoolSize ，则即使有线程是空闲的也要创建一个新线程来处理这个任务。即线程池以慢启动（名词来源于 TCP 拥塞控制）的方式来创建出 corePoolSize 个线程。&lt;/li&gt;
&lt;li&gt;maximumPoolSize 线程池的最大线程数&lt;br&gt;当线程池中的线程达到 corePoolSize 个后，当且仅当任务队列满了后就会创建新线程来执行任务，直到线程数达到 maximumPoolSize 个，就不会再创建新线程，而是启动拒绝策略来拒绝当前的任务。&lt;/li&gt;
&lt;li&gt;keepAliveTime 线程保持活跃时间&lt;br&gt;如果线程空闲时间超过 keepAliveTime ，就对该线程进行回收，直到线程数不再大于 corePoolSize 。设置 allowsCoreThreadTimeOut 可以在线程数小于等于 corePoolSize 的情况下继续回收。&lt;/li&gt;
&lt;li&gt;unit keepAliveTime的单位&lt;/li&gt;
&lt;li&gt;workQueue 保存任务的阻塞队列&lt;br&gt;可以使用 LinkedBlockingQueue 无界队列，也可以使用 ArrayBlockingQueue 等有界队列。&lt;/li&gt;
&lt;li&gt;threadFactory 创建线程的工厂类&lt;br&gt;默认使用 Executors.defaultThreadFactory() 创建线程，这些线程在同一个 ThreadGroup 中并且具有相同的优先级和非守护进程状态。通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态等等。&lt;/li&gt;
&lt;li&gt;handler 任务拒绝策略&lt;br&gt;当 Executor 关闭中或终止，或因线程、队列已满而处理不了新任务时，将调用 RejectedExecutionHandler 处理这个任务。默认有四种实现：AbortPolicy，CallerRunsPolicy，DiscardPolicy 和 DiscardOldestPolicy。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;execute-源码分析&quot;&gt;&lt;a href=&quot;#execute-源码分析&quot; class=&quot;headerlink&quot; title=&quot;execute 源码分析&quot;&gt;&lt;/a&gt;execute 源码分析&lt;/h3&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Runnable command&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (command == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt; corePoolSize) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (addWorker(command, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c = ctl.&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; recheck = ctl.&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            reject(command);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;workerCountOf(recheck&lt;/span&gt;) &lt;/span&gt;== &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addWorker(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;!addWorker(command, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;title&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;command&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;execute() 是最核心的提交任务流程，即使是 submit() 也是对 execute() 的一层封装而已，包括了怎么把 Callable 转为 Runnable。&lt;/p&gt;
&lt;p&gt;execute 主要有3步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查线程池中的线程数是否小于 corePoolSize ，如果小于，则创建一个新线程（Worker）执行这个任务。&lt;/li&gt;
&lt;li&gt;如果线程池中的线程数大于等于 corePoolSize ，则检查线程池的运行状态并且尝试把新任务放进队列中。如果可以放到队列中，还需要判断当前是否有工作线程，没有的话就创建一个空的工作线程去执行队列中的任务（处理 corePoolSize=0 的情况）。&lt;/li&gt;
&lt;li&gt;如果任务队列已经放不下任务了，则尝试继续创建一个新线程来处理这个任务。如果当前线程数已经超过 maximumPoolSize 或线程池不在运行状态中则会创建失败，启用拒绝策略处理这个任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;吐槽一下感觉这段代码写得不怎么清晰易懂，放在业务系统中就是不合格的代码啊。&lt;/p&gt;
&lt;h3 id=&quot;addWorker-源码分析&quot;&gt;&lt;a href=&quot;#addWorker-源码分析&quot; class=&quot;headerlink&quot; title=&quot;addWorker 源码分析&quot;&gt;&lt;/a&gt;addWorker 源码分析&lt;/h3&gt;&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt; core) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retry:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (;;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; rs = runStateOf(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check if queue empty only if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               firstTask == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               ! workQueue.isEmpty()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (;;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; wc = workerCountOf(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (compareAndIncrementWorkerCount(c))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; retry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            c = ctl.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;();  &lt;span class=&quot;comment&quot;&gt;// Re-read ctl&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (runStateOf(c) != rs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt; retry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt; workerStarted = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt; workerAdded = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Worker w = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        w = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Worker(firstTask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread t = w.thread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mainLock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mainLock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Recheck while holding lock.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Back out on ThreadFactory failure or if&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// shut down before lock acquired.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; rs = runStateOf(ctl.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t.isAlive()) &lt;span class=&quot;comment&quot;&gt;// precheck that t is startable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalThreadStateException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    workers.&lt;span class=&quot;built_in&quot;&gt;add&lt;/span&gt;(w);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; s = workers.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (s &amp;gt; largestPoolSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        largestPoolSize = s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    workerAdded = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mainLock.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workerAdded) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                workerStarted = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (! workerStarted)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addWorkerFailed(w);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; workerStarted;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码看上去一大段，实际就做了两件事，大部分都是在处理 Race Condition。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查线程池状态和线程数的限制，通过后将线程池的线程数+1。这里有一个参数 core 来控制是创建核心线程还是普通线程。核心线程的限制是 corePoolSize ，普通线程的限制是 maximumPoolSize ，还有一个 CAPACITY 是 ThreadPoolExecutor 本身限制的最大线程数。&lt;/li&gt;
&lt;li&gt;创建一个新的 Worker（工作线程），把它加入到线程池 workers 中。如果添加成功，则真正创建并运行这个线程（ Thread.start() ）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Worker-源码分析&quot;&gt;&lt;a href=&quot;#Worker-源码分析&quot; class=&quot;headerlink&quot; title=&quot;Worker 源码分析&quot;&gt;&lt;/a&gt;Worker 源码分析&lt;/h3&gt;&lt;p&gt;到这里我们需要关注一下 Worker 这个类了。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Set containing all worker threads in pool. Accessed only when&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * holding mainLock.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HashSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Worker&lt;/span&gt;&amp;gt; workers = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HashSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Worker&lt;/span&gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ... 省略 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Worker&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractQueuedSynchronizer&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implements &lt;span class=&quot;type&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... 省略 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** Thread this worker is running in.  Null if factory fails. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt; thread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** Initial task to run.  Possibly null. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;Runnable&lt;/span&gt; firstTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Creates with given first task and thread from ThreadFactory.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param firstTask the first task (null if none)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;Worker&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;Runnable&lt;/span&gt; firstTask) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setState(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// inhibit interrupts until runWorker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.firstTask = firstTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** Delegates main run loop to outer runWorker  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        runWorker(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... 省略 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到 ThreadPoolExecutor 的线程池实际上就是一个名为 workers 的 HashSet，而这里的线程又是封装在一个内置类 Worker 中的。&lt;/p&gt;
&lt;p&gt;Worker 内置了一个线程 Thread，而它本身又实现了 Runnable 接口，是一个可执行的“任务”，这个“任务”就是 runWorker()，下面来细说。&lt;/p&gt;
&lt;h3 id=&quot;runWorker-源码分析&quot;&gt;&lt;a href=&quot;#runWorker-源码分析&quot; class=&quot;headerlink&quot; title=&quot;runWorker 源码分析&quot;&gt;&lt;/a&gt;runWorker 源码分析&lt;/h3&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Runnable getTask() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; timedOut = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// Did the last poll() time out?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (;;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = ctl.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rs = runStateOf(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Check if queue empty only if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            decrementWorkerCount();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; wc = workerCountOf(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Are workers subject to culling?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; (wc &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || workQueue.isEmpty())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (compareAndDecrementWorkerCount(c))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Runnable r = timed ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                workQueue.take();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (r != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            timedOut = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException retry) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            timedOut = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; runWorker(Worker w) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Thread wt = Thread.currentThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Runnable &lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt; = w.firstTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w.firstTask = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w.unlock(); &lt;span class=&quot;comment&quot;&gt;// allow interrupts&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt; != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || (&lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt; = getTask()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            w.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// If pool is stopping, ensure thread is interrupted;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// if not, ensure thread is not interrupted.  This&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// requires a recheck in second case to deal with&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// shutdownNow race while clearing interrupt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((runStateAtLeast(ctl.get(), STOP) ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 (Thread.interrupted() &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                !wt.isInterrupted())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wt.interrupt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                beforeExecute(wt, &lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Throwable thrown = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt;.run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RuntimeException x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    thrown = x; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Error x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    thrown = x; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    thrown = x; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Error(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    afterExecute(&lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt;, thrown);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;task&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                w.completedTasks++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                w.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        completedAbruptly = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        processWorkerExit(w, completedAbruptly);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;runWorker() 就是做了这么一件事：执行 Worker 本身的 task，然后不断从队列中取出新的 task 继续执行；或者在空闲等待时间超过 keepAliveTime 后被回收。&lt;/p&gt;
&lt;h2 id=&quot;Executors&quot;&gt;&lt;a href=&quot;#Executors&quot; class=&quot;headerlink&quot; title=&quot;Executors&quot;&gt;&lt;/a&gt;Executors&lt;/h2&gt;&lt;p&gt;Executors 是为 ExecutorService 提供便捷的工具类，包括各种通用 ExecutorService 的工厂方法。&lt;/p&gt;
&lt;h3 id=&quot;newFixedThreadPool&quot;&gt;&lt;a href=&quot;#newFixedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;newFixedThreadPool&quot;&gt;&lt;/a&gt;newFixedThreadPool&lt;/h3&gt;&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nThreads, ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  threadFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;固定大小的线程池，corePoolSize 和 maximumPoolSize 都为 nThreads，线程不会回收，无界队列。&lt;/p&gt;
&lt;h3 id=&quot;newSingleThreadExecutor&quot;&gt;&lt;a href=&quot;#newSingleThreadExecutor&quot; class=&quot;headerlink&quot; title=&quot;newSingleThreadExecutor&quot;&gt;&lt;/a&gt;newSingleThreadExecutor&lt;/h3&gt;&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;L, TimeUnit.MILLISECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                threadFactory));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个单线程的线程池，corePoolSize 和 maximumPoolSize 都是1，线程不会回收，无界队列。&lt;/p&gt;
&lt;h3 id=&quot;newCachedThreadPool&quot;&gt;&lt;a href=&quot;#newCachedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;newCachedThreadPool&quot;&gt;&lt;/a&gt;newCachedThreadPool&lt;/h3&gt;&lt;figure class=&quot;highlight aspectj&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;L, TimeUnit.SECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;ExecutorService &lt;span class=&quot;title&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;L, TimeUnit.SECONDS,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  threadFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CachedThreadPool 比较难理解，它到底什么样的线程池呢？&lt;/p&gt;
&lt;p&gt;首先它有一些特性：corePoolSize = 0，maximumPoolSize 可以认为是没有限制，然后还用了一个很特别的阻塞队列 SynchronousQueue。&lt;/p&gt;
&lt;p&gt;SynchronousQueue 这个队列特别有意思，它是个没有容量不能存放任务的队列。想 put 一个任务，必须有另一个线程正好在另一端等待着 poll 或者 take，否则 put 的这个线程就会一直等着。如果是 offer 的话会直接返回 false。&lt;/p&gt;
&lt;p&gt;结合 execute 的过程，以及 corePoolSize = 0 这个特性，我们就会发现 CachedThreadPool 实际上就是：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;每提交一个新任务，如果有线程空闲，就分配给这个线程；没有的话就创建一个新线程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实际上就是把一个线程缓存了1分钟（超过1分钟空闲就回收），并且去掉了队列的延迟和缓冲作用。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;ScheduledThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ScheduledThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ScheduledThreadPoolExecutor&quot;&gt;&lt;/a&gt;ScheduledThreadPoolExecutor&lt;/h2&gt;&lt;p&gt;（未完待续）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Runnable&quot;&gt;&lt;a href=&quot;#Runnable&quot; class=&quot;headerlink&quot; title=&quot;Runnable&quot;&gt;&lt;/a&gt;Runnable&lt;/h2&gt;&lt;p&gt;Runnable 是 java.lang 包中定义的接口，表示一个可被线程执行的类。接口定义了一个 run() 方法来指定线程执行的动作。从现实世界角度讲，Runnable 就像一个任务。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 插件推荐</title>
    <link href="http://blog.abandonzhang.me/2017/05/03/Idea-Plugin/"/>
    <id>http://blog.abandonzhang.me/2017/05/03/Idea-Plugin/</id>
    <published>2017-05-03T15:37:39.000Z</published>
    <updated>2018-01-21T10:14:19.678Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Maven-Helper&quot;&gt;&lt;a href=&quot;#Maven-Helper&quot; class=&quot;headerlink&quot; title=&quot;Maven Helper&quot;&gt;&lt;/a&gt;Maven Helper&lt;/h2&gt;&lt;p&gt;—— 查看和解决依赖冲突&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;安装好插件后，打开项目中的 pom 文件，左下角就会出现 Dependency Analyzer。&lt;br&gt;里面还可以邮件依赖的版本选择 Exclude，不需要手动。不过需要注意它的 Exclude 比较粗暴，可能直接把冲突依赖的某个父级组件去掉了&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;FindBugs-IDEA&quot;&gt;&lt;a href=&quot;#FindBugs-IDEA&quot; class=&quot;headerlink&quot; title=&quot;FindBugs-IDEA&quot;&gt;&lt;/a&gt;FindBugs-IDEA&lt;/h2&gt;&lt;p&gt;—— 代码审查&lt;/p&gt;
&lt;h3 id=&quot;使用-1&quot;&gt;&lt;a href=&quot;#使用-1&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 Project、Module、Package 或 Class 上右击，选择 “FindBugs”&lt;/li&gt;
&lt;li&gt;选择分析 “Project”、“Module”、“Package(s)” 还是 “File(s)”&lt;/li&gt;
&lt;li&gt;在IDE底部 “FindBugs-IDEA” 标签中看详细的分析结果&lt;/li&gt;
&lt;li&gt;双击一条结果，跳转到具体的代码行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Coverage&quot;&gt;&lt;a href=&quot;#Coverage&quot; class=&quot;headerlink&quot; title=&quot;Coverage&quot;&gt;&lt;/a&gt;Coverage&lt;/h2&gt;&lt;p&gt;—— 查看单测代码覆盖率&lt;/p&gt;
&lt;h3 id=&quot;使用-2&quot;&gt;&lt;a href=&quot;#使用-2&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;选择 Analyze → Show Coverage Data&lt;/li&gt;
&lt;li&gt;添加 coverage suites（如 jacoco.exec ）&lt;/li&gt;
&lt;li&gt;点击 Show selected&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;IdeaVim&quot;&gt;&lt;a href=&quot;#IdeaVim&quot; class=&quot;headerlink&quot; title=&quot;IdeaVim&quot;&gt;&lt;/a&gt;IdeaVim&lt;/h2&gt;&lt;p&gt;给用惯 Vim 的人用&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven-Helper&quot;&gt;&lt;a href=&quot;#Maven-Helper&quot; class=&quot;headerlink&quot; title=&quot;Maven Helper&quot;&gt;&lt;/a&gt;Maven Helper&lt;/h2&gt;&lt;p&gt;—— 查看和解决依赖冲突&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;安装好插件后，打开项目中的 pom 文件，左下角就会出现 Dependency Analyzer。&lt;br&gt;里面还可以邮件依赖的版本选择 Exclude，不需要手动。不过需要注意它的 Exclude 比较粗暴，可能直接把冲突依赖的某个父级组件去掉了&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 存储引擎学习 —— 锁</title>
    <link href="http://blog.abandonzhang.me/2017/02/27/MySQL-InnoDB-Locks/"/>
    <id>http://blog.abandonzhang.me/2017/02/27/MySQL-InnoDB-Locks/</id>
    <published>2017-02-27T14:33:38.000Z</published>
    <updated>2018-01-21T10:14:19.672Z</updated>
    
    <content type="html">&lt;p&gt;注：本文的源码均来自 &lt;a href=&quot;https://github.com/percona/percona-server/tree/release-5.7.17-12&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Percona Server release-5.7.17-12&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock-Modes&quot;&gt;&lt;a href=&quot;#Lock-Modes&quot; class=&quot;headerlink&quot; title=&quot;Lock Modes&quot;&gt;&lt;/a&gt;Lock Modes&lt;/h2&gt;&lt;p&gt;Lock Mode 表示 InnoDB 中基本的加锁模式。在 /include/lock0type.h 中定义：&lt;br&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; Basic lock modes &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum lock_mode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_IS = 0,    /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; intention shared &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_IX,        /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; intention exclusive &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_S,         /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; shared &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_X,         /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; exclusive &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_AUTO_INC,  /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; locks the auto-inc counter of a table in an exclusive mode &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NONE,      /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; this is used elsewhere to note consistent read &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NUM = LOCK_NONE, /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; number of lock modes &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NONE_UNSET = 255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在 /include/lock0lock.h 中定义了获取加锁模式的掩码：&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Lock modes and types */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_MODE_MASK  0xFUL   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; mask used to extract mode from the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                type_mode field in a lock */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以通过掩码从 lock 对象的 type_mode 属性中获取到该 lock 的加锁模式。&lt;/p&gt;
&lt;p&gt;下面分别介绍一下几种加锁模式。&lt;/p&gt;
&lt;h3 id=&quot;Shared-Lock-amp-amp-Exclusive-Lock&quot;&gt;&lt;a href=&quot;#Shared-Lock-amp-amp-Exclusive-Lock&quot; class=&quot;headerlink&quot; title=&quot;Shared Lock &amp;amp;&amp;amp; Exclusive Lock&quot;&gt;&lt;/a&gt;Shared Lock &amp;amp;&amp;amp; Exclusive Lock&lt;/h3&gt;&lt;p&gt;S锁和X锁是最常见的两种锁模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S锁之间是兼容（Compatible）的，即一个S锁可以加在一个已有S锁的对象上。&lt;/li&gt;
&lt;li&gt;X锁与任何锁都是冲突（Conflict）的，即一个S/X锁不可以加在一个已有X锁的对象上，一个X锁也不可以加在一个已有S/X锁的对象上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;S锁通常用于 Locking Reads（中文有时候类似的叫作“当前读”）下读操作的授权，X锁通常用于写操作的授权。&lt;/p&gt;
&lt;h3 id=&quot;Intention-Lock&quot;&gt;&lt;a href=&quot;#Intention-Lock&quot; class=&quot;headerlink&quot; title=&quot;Intention Lock&quot;&gt;&lt;/a&gt;Intention Lock&lt;/h3&gt;&lt;p&gt;意向锁是&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_granularity_locking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多粒度锁（MGL）&lt;/a&gt;的加锁方式中引入的一种锁，解决了给祖先节点（粗力度锁）加锁时需要遍历子辈节点（细粒度锁）的问题。MySQL 中也使用了多粒度锁（表锁，行锁），因此 MySQL 中也需要意向锁。&lt;/p&gt;
&lt;p&gt;与S锁和X锁相对应，意向锁也分为意向共享锁（IS锁）和意向排它锁（IX锁）。（其他意向锁实现中还有一种 SIX 锁，不过 InnoDB 中没有）&lt;/p&gt;
&lt;p&gt;意向锁协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在为一个节点加S、IS锁前，需要它的所有祖先节点都持有IS锁或者约束更强的IX锁。&lt;/li&gt;
&lt;li&gt;在为一个节点加X、IX锁前，需要它的所有祖先节点都持有IX锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;意向锁之间是互相兼容的，它们只会与S、X锁冲突：IS锁与X锁有冲突，IX锁与S、X锁都冲突。&lt;/p&gt;
&lt;h4 id=&quot;Intention-Lock-in-InnoDB&quot;&gt;&lt;a href=&quot;#Intention-Lock-in-InnoDB&quot; class=&quot;headerlink&quot; title=&quot;Intention Lock in InnoDB&quot;&gt;&lt;/a&gt;Intention Lock in InnoDB&lt;/h4&gt;&lt;p&gt;在 InnoDB 中，意向锁是一个表级锁，表示这个表的某些行即将或正在持有相应的行锁。&lt;/p&gt;
&lt;p&gt;下面来一个实例：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 Show Engine InnoDB Status\G 可以看到（需要通过 CREATE TABLE innodb_lock_monitor (a INT) ENGINE=INNODB 打开 InnoDB 的锁监控）：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TABLE &lt;span class=&quot;keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`test`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;D7188DE9 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RECORD&lt;/span&gt; LOCKS &lt;span class=&quot;keyword&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;200923&lt;/span&gt; page &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`PRIMARY`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`test`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;D7188DE9 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; S locks rec but &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; gap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Auto-increment-Lock&quot;&gt;&lt;a href=&quot;#Auto-increment-Lock&quot; class=&quot;headerlink&quot; title=&quot;Auto-increment Lock&quot;&gt;&lt;/a&gt;Auto-increment Lock&lt;/h3&gt;&lt;p&gt;在 InnoDB 中，每个含有自增长列的表都有一个自增长计数器，插入时会将这个自增长的计数器值加1然后赋给自增长列。&lt;/p&gt;
&lt;p&gt;AUTO-INC Lock 是 InnoDB 防止多事务并发插入获取自增值时发生竞争条件（Race Condition）的一种实现。它是一种特殊的表级锁，并且为了提高并发性能，它不会等到事务结束后才释放，而是在插入语句完成后便立即释放。&lt;/p&gt;
&lt;h4 id=&quot;Mutex-Lock-and-Statement-Lock&quot;&gt;&lt;a href=&quot;#Mutex-Lock-and-Statement-Lock&quot; class=&quot;headerlink&quot; title=&quot;Mutex Lock and Statement Lock&quot;&gt;&lt;/a&gt;Mutex Lock and Statement Lock&lt;/h4&gt;&lt;p&gt;如上所说，AUTO-INC Lock 是一个语句级别的锁（Statement Lock），但它的并发性能仍然不够高：另一个事务的插入语句仍然需要等前一个事务的插入语句执行完才会开始执行。如果前一个事务是一个大数据量的批量插入操作，就会阻塞另一个事务的插入操作。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，InnoDB 提供了另一种基于操作系统的 Mutex 互斥锁。它会在计数器分配完自增值后就立即释放锁。&lt;/p&gt;
&lt;p&gt;InnoDB 提供了一个参数 innodb_autoinc_lock_mode 来配置自增的优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;innodb_autoinc_lock_mode=0&lt;br&gt;所有的“INSERT-like”语句都会在需要申请自增值时加上 AUTO-INC Lock。（“INSERT-like”语句指 Insert, Insert … Select, Replace, Replace … Select, Load Data）&lt;/li&gt;
&lt;li&gt;innodb_autoinc_lock_mode=1（默认配置）&lt;br&gt;“Simple inserts”语句会通过 Mutex 锁来获取需要数量的自增值去分配，但是当有另一个事务已持有 AUTO-INC Lock 时，“Simple inserts”语句还是需要等待 AUTO-INC Lock 释放；“Bulk inserts”语句保持传统的使用 AUTO-INC Lock 的加锁方式。（“Simple inserts”语句是指能够确定插入行数的 Insert 语句，如 Insert Into … Values；“Bulk inserts”语句就是指无法事先确定插入行数的 Insert 语句，如 Insert … Select）&lt;/li&gt;
&lt;li&gt;innodb_autoinc_lock_mode=2&lt;br&gt;所有的“INSERT-like”语句都会使用 Mutex 锁而不是 AUTO-INC Lock。在这个模式下，“Bulk Insert”插入是不能保证自增值是连续的；更重要的是，Statement-Base Replication 的主从一致会有问题，需要使用 Row-Base Replication （Why?）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Compatibility-Matrix&quot;&gt;&lt;a href=&quot;#Compatibility-Matrix&quot; class=&quot;headerlink&quot; title=&quot;Compatibility Matrix&quot;&gt;&lt;/a&gt;Compatibility Matrix&lt;/h3&gt;&lt;p&gt;InnoDB 在 /include/lock0priv.h 文件中维护了一份各个锁模式之间的互斥模型：&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; const &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; lock_compatibility_matrix[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/**         IS     IX       S     X       AI */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* IS */&lt;/span&gt; &amp;#123;  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* IX */&lt;/span&gt; &amp;#123;  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* S  */&lt;/span&gt; &amp;#123;  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* X  */&lt;/span&gt; &amp;#123;  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/* AI */&lt;/span&gt; &amp;#123;  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;TRUE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;,  &lt;span class=&quot;keyword&quot;&gt;FALSE&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock-Type&quot;&gt;&lt;a href=&quot;#Lock-Type&quot; class=&quot;headerlink&quot; title=&quot;Lock Type&quot;&gt;&lt;/a&gt;Lock Type&lt;/h2&gt;&lt;p&gt;/include/lock0lock.h 定义了 InnoDB 中用到的锁的类型。这是另一个维度的定义，与 Lock Mode 并不冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Lock types */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 笔者注：这里定义了两种基本类型 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_TABLE  16  &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; table lock */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_REC    32  &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; record lock */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 笔者注：定义了基本类型的掩码，可以从 lock 对象的 type_mode 属性中提取出 lock 的基本类型 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_TYPE_MASK  0xF0UL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Waiting lock flag; when set, it means that the lock has not yet been granted, it is just waiting for its turn in the wait queue */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_WAIT   256 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 笔者注：这里定义了几种更具体的类型 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Precise modes */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_ORDINARY   0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_GAP    512&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_REC_NOT_GAP 1024&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_INSERT_INTENTION 2048&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_PREDICATE  8192&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LOCK_PRDT_PAGE  16384&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面来具体说一下各个类型。（LOCK_PREDICATE、LOCK_PRDT_PAGE 资料比较少，还不太了解，先省略）&lt;/p&gt;
&lt;h3 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h3&gt;&lt;p&gt;LOCK_TABLE 和 LOCK_REC 是两个基本类型，分别表示表锁和记录锁（行锁）。其中 LOCK_REC 是一个宽泛的概念，并不特指锁的范围是一条记录。他是 LOCK_ORDINARY、LOCK_GAP、LOCK_REC_NOT_GAP 的一个汇总概念，广义上讲他们都是记录锁。&lt;/p&gt;
&lt;h3 id=&quot;LOCK-REC-NOT-GAP-Record-Lock&quot;&gt;&lt;a href=&quot;#LOCK-REC-NOT-GAP-Record-Lock&quot; class=&quot;headerlink&quot; title=&quot;LOCK_REC_NOT_GAP (Record Lock)&quot;&gt;&lt;/a&gt;LOCK_REC_NOT_GAP (Record Lock)&lt;/h3&gt;&lt;p&gt;这个是真正狭义上的记录锁，它的锁定范围就是 InnoDB 中的一条索引记录。&lt;/p&gt;
&lt;p&gt;在 Repeatable Read 隔离级别下，当遇到&lt;br&gt;1.唯一索引（或主键索引）&lt;br&gt;2.且是等值查询&lt;br&gt;3.且对应记录存在&lt;br&gt;时，InnoDB 就会在该索引记录上加一个 LOCK_REC_NOT_GAP 锁。&lt;/p&gt;
&lt;p&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bizacct &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;66283&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里 id 是主键索引，并且 66283 这个值对应的记录是存在的。Show Engine InnoDB Status 一下:&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;---TRANSACTION 2044, ACTIVE 1 sec&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;(s), &lt;span class=&quot;keyword&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20610&lt;/span&gt;, OS &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; handle &lt;span class=&quot;number&quot;&gt;0x7f28cfe7c700&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;50114&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;172.26&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.113&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;admin&lt;/span&gt; cleaning up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2044&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RECORD&lt;/span&gt; LOCKS &lt;span class=&quot;keyword&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; page &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1621&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;168&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`PRIMARY`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2044&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; S locks rec but &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; gap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到在对应的索引记录上有一个 lock mode S locks rec but not gap。&lt;/p&gt;
&lt;p&gt;在 Read Committed 隔离级别下，不会产生下面提到的 Gap Lock，因此索引记录上加的也都是 LOCK_REC_NOT_GAP 锁。&lt;/p&gt;
&lt;h3 id=&quot;LOCK-GAP-Gap-Lock&quot;&gt;&lt;a href=&quot;#LOCK-GAP-Gap-Lock&quot; class=&quot;headerlink&quot; title=&quot;LOCK_GAP (Gap Lock)&quot;&gt;&lt;/a&gt;LOCK_GAP (Gap Lock)&lt;/h3&gt;&lt;p&gt;在 InnoDB 默认的隔离级别 Repeatable Read 下，为了解决 Locking Reads 下的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2#.E5.B9.BB.E5.BD.B1.E8.AF.BB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;幻读&lt;/a&gt;问题，InnoDB 会在扫描到的索引记录与上一个索引记录之间的间隙上也加一把锁，这种类型的锁就叫 Gap 锁。Gap 锁是 Repeatable Read 隔离级别下才有的锁。&lt;/p&gt;
&lt;p&gt;索引的“间隙”体现在索引列的值上则是一个左开右闭的区间。如索引列X有值4和6，那么6对应的 Gap 锁就是 (4,6]&lt;/p&gt;
&lt;p&gt;在 InnoDB 中，Gap 锁通常不会单独出现，而是以下面将要说到的 Next-key 锁的方式出现。当然，在特定条件下还是存在单独的 Gap 锁的。比如如果这条记录不存在，那不就没法加 Record 锁了么。&lt;/p&gt;
&lt;p&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bizacct &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;23000000&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里 id 是主键索引，但是 23000000 这个值对应的记录是不存在的。Show Engine InnoDB Status 一下:&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;---TRANSACTION 2049, ACTIVE 17 sec&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;(s), &lt;span class=&quot;keyword&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20610&lt;/span&gt;, OS &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; handle &lt;span class=&quot;number&quot;&gt;0x7f28cfe7c700&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;51053&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;172.26&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.113&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;admin&lt;/span&gt; cleaning up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2049&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RECORD&lt;/span&gt; LOCKS &lt;span class=&quot;keyword&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; page &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;31846&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;144&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`PRIMARY`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2049&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; S locks gap &lt;span class=&quot;keyword&quot;&gt;before&lt;/span&gt; rec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结一下：无论是唯一索引还是普通索引，无论是等值查询还是范围查询，在 Repeatable Read 隔离级别下，只要查找的对应记录不存在，就会加一把 LOCK_GAP 锁。&lt;/p&gt;
&lt;h3 id=&quot;LOCK-ORDINARY-Next-key-Lock&quot;&gt;&lt;a href=&quot;#LOCK-ORDINARY-Next-key-Lock&quot; class=&quot;headerlink&quot; title=&quot;LOCK_ORDINARY (Next-key Lock)&quot;&gt;&lt;/a&gt;LOCK_ORDINARY (Next-key Lock)&lt;/h3&gt;&lt;p&gt;在 Repeatable Read 隔离级别下，大部分情况下 InnoDB 都会同时在索引记录上加一把 Record Lock 和一把 Gap Lock，这样一套组合锁就叫 Next-key 锁。&lt;/p&gt;
&lt;p&gt;这些情况有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非唯一索引下的等值查询（对应记录存在）&lt;/li&gt;
&lt;li&gt;范围查询（对应记录存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bizacct &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; login=&lt;span class=&quot;string&quot;&gt;&quot;mtpm&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bizacct &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; login=&lt;span class=&quot;string&quot;&gt;&quot;mtpm02&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;share&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里 login 是普通索引，mtpm 对应的记录是存在且唯一的，mtpm02 对应的记录是存在且有多个的。它们两个 Show Engine InnoDB Status 后均是类似:&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;---TRANSACTION 2048, ACTIVE 121 sec&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;(s), &lt;span class=&quot;keyword&quot;&gt;heap&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1184&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt;(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20610&lt;/span&gt;, OS &lt;span class=&quot;keyword&quot;&gt;thread&lt;/span&gt; handle &lt;span class=&quot;number&quot;&gt;0x7f28cfe7c700&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;50364&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;172.26&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.113&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;admin&lt;/span&gt; cleaning up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RECORD&lt;/span&gt; LOCKS &lt;span class=&quot;keyword&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; page &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11736&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;728&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`idx_login`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; S&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;RECORD&lt;/span&gt; LOCKS &lt;span class=&quot;keyword&quot;&gt;space&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; page &lt;span class=&quot;keyword&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11736&lt;/span&gt; n bits &lt;span class=&quot;number&quot;&gt;728&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`idx_login`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`zzptest`&lt;/span&gt;.&lt;span class=&quot;string&quot;&gt;`bizacct`&lt;/span&gt; trx &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mode&lt;/span&gt; S locks gap &lt;span class=&quot;keyword&quot;&gt;before&lt;/span&gt; rec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到在对应的索引记录上有一个 lock mode S 以及 lock mode S locks gap before rec。&lt;/p&gt;
&lt;h3 id=&quot;Insert-Intention-Locks（LOCK-INSERT-INTENTION）&quot;&gt;&lt;a href=&quot;#Insert-Intention-Locks（LOCK-INSERT-INTENTION）&quot; class=&quot;headerlink&quot; title=&quot;Insert Intention Locks（LOCK_INSERT_INTENTION）&quot;&gt;&lt;/a&gt;Insert Intention Locks（LOCK_INSERT_INTENTION）&lt;/h3&gt;&lt;p&gt;InnoDB 在 Insert 一条记录之后会在这条记录上加一把 X 锁。但是在 Insert 之前，也需要加锁来防止插入行可能造成的锁冲突，此时行记录还不存在所以无法加记录锁。&lt;/p&gt;
&lt;p&gt;插入意向锁是 Insert 操作前加的一种特殊的 Gap 锁。其特殊之处在于：同一段 Gap 上的插入意向锁，如果对应的插入行不同，它们是不会互相排斥的（猜测是因为意向锁之间也不会互相排斥，所以这个就叫插入意向锁）。当然，插入意向锁也会和普通的 Gap 锁一样对相应的记录锁和 Gap 锁排斥。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MySQL 5.7 Reference Manual - InnoDB Locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MySQL 5.7 Reference Manual - AUTO_INCREMENT Handling in InnoDB&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;注：本文的源码均来自 &lt;a href=&quot;https://github.com/percona/percona-server/tree/release-5.7.17-12&quot;&gt;Percona Server release-5.7.17-12&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Lock-Modes&quot;&gt;&lt;a href=&quot;#Lock-Modes&quot; class=&quot;headerlink&quot; title=&quot;Lock Modes&quot;&gt;&lt;/a&gt;Lock Modes&lt;/h2&gt;&lt;p&gt;Lock Mode 表示 InnoDB 中基本的加锁模式。在 /include/lock0type.h 中定义：&lt;br&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; Basic lock modes &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum lock_mode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_IS = 0,    /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; intention shared &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_IX,        /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; intention exclusive &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_S,         /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; shared &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_X,         /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; exclusive &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_AUTO_INC,  /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; locks the auto-inc counter of a table in an exclusive mode &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NONE,      /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; this is used elsewhere to note consistent read &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NUM = LOCK_NONE, /&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; number of lock modes &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LOCK_NONE_UNSET = 255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.abandonzhang.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Maven 核心概念和配置</title>
    <link href="http://blog.abandonzhang.me/2017/01/29/Maven/"/>
    <id>http://blog.abandonzhang.me/2017/01/29/Maven/</id>
    <published>2017-01-29T03:09:18.000Z</published>
    <updated>2018-01-21T10:14:19.674Z</updated>
    
    <content type="html">&lt;h2 id=&quot;POM&quot;&gt;&lt;a href=&quot;#POM&quot; class=&quot;headerlink&quot; title=&quot;POM&quot;&gt;&lt;/a&gt;POM&lt;/h2&gt;&lt;p&gt;就像 Make 的 Makefile、Ant 的 build.xml 一样，Maven 项目的核心是 pom.xml。POM（Project-Object Model，项目对象模型）定义了项目的基本信息，以及构建和依赖的管理等。&lt;/p&gt;
&lt;p&gt;POM 中的核心元素有：坐标、构建、依赖、聚合与继承、仓库。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;坐标（Coordinate）&quot;&gt;&lt;a href=&quot;#坐标（Coordinate）&quot; class=&quot;headerlink&quot; title=&quot;坐标（Coordinate）&quot;&gt;&lt;/a&gt;坐标（Coordinate）&lt;/h2&gt;&lt;p&gt;Maven 通过坐标唯一标识一个构件（ Maven 项目 or 模块 ），即一个坐标对应一个 JAR 包。坐标通过一组XML元素来定义：groupId、artifactId、version、packaging、classifier。其中 groupId、artifactId、version 是必须定义的，packaging 是可选的，classifier 是无法直接定义的，需要通过构建插件生成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;groupId&lt;ul&gt;
&lt;li&gt;构件隶属项目或组织的唯一标识，通常用域名的反向方式表示。如 Maven 自带构建插件的 groupID 都是 org.apache.maven.plugins。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;artifactId&lt;ul&gt;
&lt;li&gt;构件的唯一标识。如 Maven 自带的编译插件的 artifactId 为 maven-compiler-plugin。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;version&lt;ul&gt;
&lt;li&gt;构件的版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;packaging 是可选的，&lt;ul&gt;
&lt;li&gt;构件打包方式，常用的有 pom、jar、war、maven-plugin 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;classifier&lt;ul&gt;
&lt;li&gt;定义构建输出的一些附属构件，默认为无。如 javadoc 表示输出构件的 Java 文档，source 表示输出构件的源代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个 Maven 项目坐标定义的例子：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- pom.xml --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.sonatype.nexus&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;nexus-indexer&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;packaging&lt;/span&gt;&amp;gt;&lt;/span&gt;jar&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;packaging&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;构建（build）&quot;&gt;&lt;a href=&quot;#构建（build）&quot; class=&quot;headerlink&quot; title=&quot;构建（build）&quot;&gt;&lt;/a&gt;构建（build）&lt;/h2&gt;&lt;p&gt;自动化构建是 Maven 最主要的功能之一。Maven 对项目的的构建过程进行了抽象和统一，设计了一套完善且易扩展的构建生命周期。Maven 本身并不做任何实际的工作，实际的构建过程是交给插件来完成的。&lt;/p&gt;
&lt;h3 id=&quot;生命周期（Lifecycle）&quot;&gt;&lt;a href=&quot;#生命周期（Lifecycle）&quot; class=&quot;headerlink&quot; title=&quot;生命周期（Lifecycle）&quot;&gt;&lt;/a&gt;生命周期（Lifecycle）&lt;/h3&gt;&lt;p&gt;Maven 在 maven-core.jar 的 META-INF/plexus/components.xml 中定义了三套独立的生命周期（org.apache.maven.lifecycle.Lifecycle）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clean，清理项目。&lt;/li&gt;
&lt;li&gt;default，构建项目。&lt;/li&gt;
&lt;li&gt;site，建立项目站点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个生命周期都包含一些&lt;code&gt;阶段（Phases）&lt;/code&gt;，各个生命周期内的阶段是有顺序的，且后面的阶段依赖前面的阶段。每一个生命周期的阶段都可以通过 Maven 命令直接调用，调用后面的阶段时会把前面所有阶段都先执行。&lt;/p&gt;
&lt;h4 id=&quot;clean-lifecycle&quot;&gt;&lt;a href=&quot;#clean-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;clean lifecycle&quot;&gt;&lt;/a&gt;clean lifecycle&lt;/h4&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- maven-core.jar/META-INF/plexus/components.xml --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;phases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;pre-clean&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;clean&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;post-clean&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;phases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;default-phases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;clean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    org.apache.maven.plugins:maven-clean-plugin:2.5:clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;clean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;default-phases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;clean 生命周期包含有三个阶段： pre-clean、clean 和 post-clean。其中 clean 阶段已经内置绑定了插件 maven-clean-plugin。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当用户调用 mvn pre-clean 时，只有 pre-clean 阶段执行。&lt;/li&gt;
&lt;li&gt;当用户调用 mvn clean 的时候，pre-clean 和 clean 阶段会顺序执行。&lt;/li&gt;
&lt;li&gt;当用户调用 mvn post-clean 的时候，pre-clean、clean 和 post-clean 会顺序执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;default-lifecycle&quot;&gt;&lt;a href=&quot;#default-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;default lifecycle&quot;&gt;&lt;/a&gt;default lifecycle&lt;/h4&gt;&lt;p&gt;default 生命周期有很多阶段，下面只列出最常用的几个阶段。由于 default 生命周期的内置插件绑定与 packaging 方式有关，因此 Maven 3.x 将它放在 maven-core 的一个单独文件 META-INF/plexus/default-bindings.xml 中定义。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;常用阶段&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;内置绑定插件目标-pom&lt;/th&gt;
&lt;th&gt;*-jar&lt;/th&gt;
&lt;th&gt;*-war&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;process-resources&lt;/td&gt;
&lt;td&gt;处理项目主资源文件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;compile&lt;/td&gt;
&lt;td&gt;编译项目的主源码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;process-test-resources&lt;/td&gt;
&lt;td&gt;处理项目测试资源文件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;test-compile&lt;/td&gt;
&lt;td&gt;编译项目的测试代码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;test&lt;/td&gt;
&lt;td&gt;使用单元测试框架运行测试&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package&lt;/td&gt;
&lt;td&gt;以指定方式打包编译好的代码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;install&lt;/td&gt;
&lt;td&gt;将包安装到本地仓库&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deploy&lt;/td&gt;
&lt;td&gt;将包安装到远程仓库&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;site-lifecycle&quot;&gt;&lt;a href=&quot;#site-lifecycle&quot; class=&quot;headerlink&quot; title=&quot;site lifecycle&quot;&gt;&lt;/a&gt;site lifecycle&lt;/h4&gt;&lt;p&gt;site 用的不多这里就不说了。&lt;/p&gt;
&lt;h3 id=&quot;插件目标（Plugin-Goal）&quot;&gt;&lt;a href=&quot;#插件目标（Plugin-Goal）&quot; class=&quot;headerlink&quot; title=&quot;插件目标（Plugin Goal）&quot;&gt;&lt;/a&gt;插件目标（Plugin Goal）&lt;/h3&gt;&lt;p&gt;对于插件本身，为了能够复用代码，它往往能够完成多个任务。一个任务就是一个插件目标。&lt;/p&gt;
&lt;p&gt;例如 maven-dependency-plugin 插件有 dependency:analyze、dependency:tree 和 dependency:list 等目标，分别来做依赖分析、以树和列表形式列出已有依赖用。&lt;/p&gt;
&lt;p&gt;与构建阶段一样，插件目标也可以通过 maven 命令行直接调用，如 mvn dependency:tree、mvn dependency:analyze。&lt;/p&gt;
&lt;h3 id=&quot;插件绑定&quot;&gt;&lt;a href=&quot;#插件绑定&quot; class=&quot;headerlink&quot; title=&quot;插件绑定&quot;&gt;&lt;/a&gt;插件绑定&lt;/h3&gt;&lt;p&gt;除了 Maven 内置的各个构建阶段的插件绑定，我们也可以在 pom.xml 文件中显式地绑定插件，或者对插件做一些配置。&lt;/p&gt;
&lt;p&gt;构建阶段的插件配置在 POM 的 &lt;code&gt;&amp;lt;build&amp;gt;&lt;/code&gt; 标签中完成。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;build&amp;gt;&amp;lt;plugins&amp;gt;&lt;/code&gt; 标签声明插件的绑定和配置，每一个插件的绑定配置如下：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 插件坐标 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;x.x&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 是否需要加载这个插件的扩展，默认为 false --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;extensions&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;extensions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 这个插件的配置是否同样应用于继承了该 POM 的子 POM，默认为 true --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;inherited&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;inherited&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 不同插件有自己不同的配置项，需单独学习 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 对单独的插件目标进行配置 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 唯一标识。自定义，运行时会显示在日志上 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 指定要配置的插件目标 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;goal&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;goals&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 显式指定该插件目标绑定到哪个构建阶段，可选 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;phase&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;inherited&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;inherited&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 同上一级的 configuration，区别仅是这里针对插件目标单独配置 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;execution&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;executions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 该插件的依赖管理，配置方式与项目的依赖管理相同，不常用 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;1.&lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to the Build Lifecycle&lt;/a&gt;&lt;br&gt;2.&lt;a href=&quot;http://maven.apache.org/pom.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;POM Reference&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;依赖（dependencies）&quot;&gt;&lt;a href=&quot;#依赖（dependencies）&quot; class=&quot;headerlink&quot; title=&quot;依赖（dependencies）&quot;&gt;&lt;/a&gt;依赖（dependencies）&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POM&quot;&gt;&lt;a href=&quot;#POM&quot; class=&quot;headerlink&quot; title=&quot;POM&quot;&gt;&lt;/a&gt;POM&lt;/h2&gt;&lt;p&gt;就像 Make 的 Makefile、Ant 的 build.xml 一样，Maven 项目的核心是 pom.xml。POM（Project-Object Model，项目对象模型）定义了项目的基本信息，以及构建和依赖的管理等。&lt;/p&gt;
&lt;p&gt;POM 中的核心元素有：坐标、构建、依赖、聚合与继承、仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>META-INF 和 WEB-INF</title>
    <link href="http://blog.abandonzhang.me/2017/01/28/META-INF-and-WEB-INF/"/>
    <id>http://blog.abandonzhang.me/2017/01/28/META-INF-and-WEB-INF/</id>
    <published>2017-01-28T10:54:01.000Z</published>
    <updated>2018-01-21T10:14:19.666Z</updated>
    
    <content type="html">&lt;h2 id=&quot;WEB-INF&quot;&gt;&lt;a href=&quot;#WEB-INF&quot; class=&quot;headerlink&quot; title=&quot;WEB-INF&quot;&gt;&lt;/a&gt;WEB-INF&lt;/h2&gt;&lt;p&gt;WEB-INF 是 WAR（Web Application Archive）包的一个目录，维护一些 Web 服务端不想让客户端通过URL访问到的资源文件，比如：web.xml，以及 Java 的 classes 和 library 文件等。&lt;/p&gt;
&lt;h2 id=&quot;META-INF&quot;&gt;&lt;a href=&quot;#META-INF&quot; class=&quot;headerlink&quot; title=&quot;META-INF&quot;&gt;&lt;/a&gt;META-INF&lt;/h2&gt;&lt;p&gt;META-INF 是 JAR（Java Archive File）包的一个目录，而 JAR 包本质上就是 zip 格式的压缩包加上一个 META-INF 目录。&lt;/p&gt;
&lt;p&gt;META-INF 目录下存放 Java 应用程序的一些元信息（To configure applications, extensions, class loaders and services）。一个标准的 META-INF 目录通常都包含 MANIFEST.MF 、INDEX.LIST、*.SF、*.DSA、services/ 等文件和目录，此外也可以放一些用户自己的文件。&lt;/p&gt;
&lt;p&gt;由于 WAR 也是一个 JAR 文件，因此 WAR 包下也有 META-INF 目录。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WEB-INF&quot;&gt;&lt;a href=&quot;#WEB-INF&quot; class=&quot;headerlink&quot; title=&quot;WEB-INF&quot;&gt;&lt;/a&gt;WEB-INF&lt;/h2&gt;&lt;p&gt;WEB-INF 是 WAR（Web Application Archive）包的一个目录，维护一些 
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.abandonzhang.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《领域驱动设计》学习笔记</title>
    <link href="http://blog.abandonzhang.me/2016/10/29/DDD/"/>
    <id>http://blog.abandonzhang.me/2016/10/29/DDD/</id>
    <published>2016-10-29T11:01:57.000Z</published>
    <updated>2018-01-21T10:14:19.667Z</updated>
    
    <content type="html">&lt;p&gt;业务开发往往是为了解决真实世界中某个业务领域的具体问题，它的复杂性大多时候也取决于业务的复杂性。如何开发一个可维护的复杂业务的软件？本书提供了一种叫做&lt;code&gt;领域驱动设计&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Domain%20Driven%20Design&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;回顾：软件设计方法&quot;&gt;&lt;a href=&quot;#回顾：软件设计方法&quot; class=&quot;headerlink&quot; title=&quot;回顾：软件设计方法&quot;&gt;&lt;/a&gt;回顾：软件设计方法&lt;/h2&gt;&lt;h3 id=&quot;瀑布开发&quot;&gt;&lt;a href=&quot;#瀑布开发&quot; class=&quot;headerlink&quot; title=&quot;瀑布开发&quot;&gt;&lt;/a&gt;瀑布开发&lt;/h3&gt;&lt;p&gt;由上到下的单向过程：业务专家提出需求同分析人员交流，分析人员基于需求建立模型交给开发人员，开发人员拿到模型开始开发。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;很难预先确定所有需求，很难避免设计上有些不足。&lt;/li&gt;
&lt;li&gt;整个过程缺乏向上反馈。&lt;/li&gt;
&lt;li&gt;分析瘫痪：团队成员会因害怕做出错误的设计而止步不前。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;敏捷开发&quot;&gt;&lt;a href=&quot;#敏捷开发&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发&quot;&gt;&lt;/a&gt;敏捷开发&lt;/h3&gt;&lt;p&gt;核心观念：拥抱变化、快速迭代、当面交流、持续交付&lt;/p&gt;
&lt;p&gt;敏捷开发的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;及早发现需求或设计的不合理之处&lt;/li&gt;
&lt;li&gt;不会因害怕犯错而止步不前&lt;/li&gt;
&lt;li&gt;不需要过度设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是敏捷开发还是会有一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码持续重构，可能导致最终难以理解和维护&lt;/li&gt;
&lt;li&gt;不敢做出深度、彻底的设计&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;领域驱动设计&quot;&gt;&lt;a href=&quot;#领域驱动设计&quot; class=&quot;headerlink&quot; title=&quot;领域驱动设计&quot;&gt;&lt;/a&gt;领域驱动设计&lt;/h3&gt;&lt;p&gt;领域驱动设计是一种指导方法，可以应用在前面任何一种开发模式中。领域驱动设计展示了设计和开发如何协同工作以创建一个更好的解决方案。优良的设计会加速开发的过程，而开发过程中的反馈也会进一步优化设计。&lt;/p&gt;
&lt;h2 id=&quot;核心是领域&quot;&gt;&lt;a href=&quot;#核心是领域&quot; class=&quot;headerlink&quot; title=&quot;核心是领域&quot;&gt;&lt;/a&gt;核心是领域&lt;/h2&gt;&lt;p&gt;业务软件是为了提高业务效率，推动业务发展。而一旦软件的设计和实现偏离了业务领域，它就可能会对业务起到负面作用了。&lt;/p&gt;
&lt;p&gt;如何让软件的设计不偏离业务？最佳实践是：&lt;strong&gt;&lt;em&gt;让软件成为业务领域的映射。软件要包含领域里的重要概念和元素，并精确实现他们之间的关系&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;构建领域模型&quot;&gt;&lt;a href=&quot;#构建领域模型&quot; class=&quot;headerlink&quot; title=&quot;构建领域模型&quot;&gt;&lt;/a&gt;构建领域模型&lt;/h2&gt;&lt;p&gt;没有丰富的领域知识无法做好业务软件的设计。&lt;/p&gt;
&lt;p&gt;最了解领域知识的人是领域专家。但领域专家不了解软件设计，他们可能无法很好地将领域知识转换成软件构造。软件专家和领域专家需要讨论交流，共同完成业务领域到软件的映射。&lt;/p&gt;
&lt;h3 id=&quot;模型：通用语言&quot;&gt;&lt;a href=&quot;#模型：通用语言&quot; class=&quot;headerlink&quot; title=&quot;模型：通用语言&quot;&gt;&lt;/a&gt;模型：通用语言&lt;/h3&gt;&lt;p&gt;软件专家和领域专家需要一个通用语言来提高沟通效率，大家在交流过程中尽可能地使用通用语言而不是自己熟悉的“方言”。&lt;/p&gt;
&lt;p&gt;在与领域专家交流的过程中，软件专家从领域专家那里直接获取来的知识是无法轻易转化为代码的，需要为它建立一层抽象。一开始这个抽象是不完整的，但随着与领域专家更多更深入的交流，这个抽象会越来越完整。这个抽象就是业务领域的&lt;code&gt;模型&lt;/code&gt;。模型是对业务领域的提炼和抽象，同时它又是软件设计的蓝本，贯穿了整个软件的设计和开发阶段。&lt;/p&gt;
&lt;p&gt;领域驱动设计的核心原则就是要将&lt;code&gt;模型&lt;/code&gt;作为通用语言。所以第一步就是要创建一个植根于领域，并精确反馈出领域中的基本概念的模型。&lt;/p&gt;
&lt;h3 id=&quot;模型的表达&quot;&gt;&lt;a href=&quot;#模型的表达&quot; class=&quot;headerlink&quot; title=&quot;模型的表达&quot;&gt;&lt;/a&gt;模型的表达&lt;/h3&gt;&lt;p&gt;如何表达模型是关键。&lt;/p&gt;
&lt;h4 id=&quot;词汇表&quot;&gt;&lt;a href=&quot;#词汇表&quot; class=&quot;headerlink&quot; title=&quot;词汇表&quot;&gt;&lt;/a&gt;词汇表&lt;/h4&gt;&lt;p&gt;领域驱动设计提倡我们组建一个能精确反映领域概念的&lt;code&gt;词汇表&lt;/code&gt;，包括业务中的名词（对象）和动词（行为），并定期的检查和更新词汇的语义。&lt;/p&gt;
&lt;h4 id=&quot;UML&quot;&gt;&lt;a href=&quot;#UML&quot; class=&quot;headerlink&quot; title=&quot;UML&quot;&gt;&lt;/a&gt;UML&lt;/h4&gt;&lt;p&gt;&lt;code&gt;UML&lt;/code&gt;是记录软件关键概念（如类图）的好工具。一个将模型对应成代码的最佳实践就是为每一个模型关键概念创建一个类，这样代码更容易趋向于易读，同时也让我们可以用UML来表达模型。&lt;/p&gt;
&lt;p&gt;UML图在元素数量少的时候效果很好，但当元素个数很多的时候，UML图就会显得很乱很难读。&lt;/p&gt;
&lt;p&gt;同时，UML擅长表达元素的属性和关系，但不擅长表达元素的行为和约束，为此需要借助于文字注释。&lt;/p&gt;
&lt;h4 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h4&gt;&lt;p&gt;一个好的表达模型的方式是：&lt;strong&gt;&lt;em&gt;通过文档，创建一些小的图，每个图只包含模型的一个子集，一个重要的方面，其中可能包含若干个类和它们之间的关系，以及必要的文字注释来解释类的行为和约束&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建一张反映整个模型的大图可能很有诱惑力，但通常这很难，并且即使做出来了，它也会非常不易阅读和理解。&lt;/p&gt;
&lt;p&gt;文档必须与模型同步。避免陈旧、使用了非通用语言、不能如实反映模型的文档。&lt;/p&gt;
&lt;h2 id=&quot;模型驱动设计&quot;&gt;&lt;a href=&quot;#模型驱动设计&quot; class=&quot;headerlink&quot; title=&quot;模型驱动设计&quot;&gt;&lt;/a&gt;模型驱动设计&lt;/h2&gt;&lt;h3 id=&quot;模型与设计紧密联系&quot;&gt;&lt;a href=&quot;#模型与设计紧密联系&quot; class=&quot;headerlink&quot; title=&quot;模型与设计紧密联系&quot;&gt;&lt;/a&gt;模型与设计紧密联系&lt;/h3&gt;&lt;p&gt;讨论完模型的构建后，还需要考虑如何完成从模型到代码的转换。&lt;/p&gt;
&lt;p&gt;一个好的方式是：将领域建模和软件设计紧密关联起来，模型在构建时就要考虑软件的设计和实现。即开发人员参与到模型构建的过程中。这样做的一个显而易见的好处是避免模型构建出来后无法落地到代码中。&lt;/p&gt;
&lt;h3 id=&quot;模型驱动的设计模式&quot;&gt;&lt;a href=&quot;#模型驱动的设计模式&quot; class=&quot;headerlink&quot; title=&quot;模型驱动的设计模式&quot;&gt;&lt;/a&gt;模型驱动的设计模式&lt;/h3&gt;&lt;p&gt;模式是一些指导方法。模型驱动的设计模式可以指导我们设计出与更与模型贴近的、可持续发展的代码。&lt;/p&gt;
&lt;p&gt;下面是模型驱动设计中的一些关键元素：&lt;br&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Model%20Driven%20Design&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些元素大致分为：领域对象和领域对象的行为。&lt;/p&gt;
&lt;h4 id=&quot;分层架构（Layered-Architecture）&quot;&gt;&lt;a href=&quot;#分层架构（Layered-Architecture）&quot; class=&quot;headerlink&quot; title=&quot;分层架构（Layered Architecture）&quot;&gt;&lt;/a&gt;分层架构（Layered Architecture）&lt;/h4&gt;&lt;p&gt;分层架构是一种代码模块架构，将关键的、复杂的领域代码和其他层面的代码分开，使得代码不容易变得混乱和腐烂。主要包含了4层：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分层&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用户界面/接口层&lt;/td&gt;
&lt;td&gt;展现数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;不包含核心业务逻辑，不保存业务对象的状态，只负责任务的流程调度（第1步、第2步、……）（事务脚本模型）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;领域层&lt;/td&gt;
&lt;td&gt;核心业务逻辑层。包含业务的领域信息和业务对象的状态和行为（领域模型）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基础设施层&lt;/td&gt;
&lt;td&gt;提供各层之间的通信，与外界的通信，以及业务对象的持久化&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;实体（Entity）&quot;&gt;&lt;a href=&quot;#实体（Entity）&quot; class=&quot;headerlink&quot; title=&quot;实体（Entity）&quot;&gt;&lt;/a&gt;实体（Entity）&lt;/h4&gt;&lt;p&gt;&lt;code&gt;实体&lt;/code&gt;是指在业务领域中独立的、具有唯一标识的对象（如人、账户、订单等）。实体可以有自己的属性（成员变量）和行为（成员函数）。&lt;/p&gt;
&lt;p&gt;实体中最重要的就是它的唯一标识符（ID）。&lt;/p&gt;
&lt;p&gt;在设计过程中要注意避免出现有很多属性、承担了很多行为的“超级实体”，对这种实体进行适当的拆分。&lt;/p&gt;
&lt;h4 id=&quot;值对象（Value-Object）&quot;&gt;&lt;a href=&quot;#值对象（Value-Object）&quot; class=&quot;headerlink&quot; title=&quot;值对象（Value Object）&quot;&gt;&lt;/a&gt;值对象（Value Object）&lt;/h4&gt;&lt;p&gt;有些对象是没有唯一标识的，当它们的属性值都相同的时候，就可以把它们当做是一个全局对象。如价格、直线等。这些用来描述领域的特定方面，但是没有唯一标识符的对象，叫做&lt;code&gt;值对象&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;服务（Service）&quot;&gt;&lt;a href=&quot;#服务（Service）&quot; class=&quot;headerlink&quot; title=&quot;服务（Service）&quot;&gt;&lt;/a&gt;服务（Service）&lt;/h4&gt;&lt;p&gt;在领域中有一些重要的行为，它是不属于某个实体的。如“转账”这个行为，放在转入账户和转出账户都不合适。&lt;/p&gt;
&lt;p&gt;将这种行为实现为&lt;code&gt;服务&lt;/code&gt;对象，对象不需要保存状态，它仅仅是为领域提供相应功能。&lt;/p&gt;
&lt;p&gt;服务的三个特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务执行的操作代表了一个领域概念，这个领域概念无法隶属于一个实体或值对象。&lt;/li&gt;
&lt;li&gt;被执行的操作涉及到领域中的其他对象。&lt;/li&gt;
&lt;li&gt;操作是无状态的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;聚合（Aggregates）&quot;&gt;&lt;a href=&quot;#聚合（Aggregates）&quot; class=&quot;headerlink&quot; title=&quot;聚合（Aggregates）&quot;&gt;&lt;/a&gt;聚合（Aggregates）&lt;/h4&gt;&lt;p&gt;一个领域模型中通常会有很多对象，这些对象之间可能会存在很复杂的关系网。这些关系的类型有很多种，对每一种类型都应该有相应的代码机制来实现它。&lt;/p&gt;
&lt;p&gt;有时候，一些属性或对象是与多个对象产生关联的，当修改或删除它时，就会带来数据一致性的问题。通常会使用事务来处理数据一致性，但如果模型设计不好则会导致数据库性能很差。我们更期望可以在模型中解决数据一致性问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;聚合&lt;/code&gt;是将有关联的对象聚合在一起，通过&lt;code&gt;边界&lt;/code&gt;与其他外部对象划分开。每一个聚合都有一个根实体，叫做&lt;code&gt;聚合根&lt;/code&gt;。它有以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;聚合根是该聚合中外界唯一可以访问（或引用）的对象。&lt;/li&gt;
&lt;li&gt;聚合根可以引用聚合内的任意对象，聚合内的任意对象也可以互相引用。&lt;/li&gt;
&lt;li&gt;聚合根实体必须拥有全局唯一标识符，聚合内的其他实体可以是聚合内的唯一标识。&lt;/li&gt;
&lt;li&gt;外界想获取或更改聚合内的其他对象，必须通过聚合根来请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;聚合将数据一致性的问题收敛到了聚合内部，变得可控。&lt;/p&gt;
&lt;p&gt;如果外界想获取聚合内的其他对象，建议传递给外界的是对象的一个副本（更新无效）。&lt;/p&gt;
&lt;h4 id=&quot;工厂（Factory）&quot;&gt;&lt;a href=&quot;#工厂（Factory）&quot; class=&quot;headerlink&quot; title=&quot;工厂（Factory）&quot;&gt;&lt;/a&gt;工厂（Factory）&lt;/h4&gt;&lt;p&gt;对象的创建有两种方式：构造器和工厂。&lt;/p&gt;
&lt;p&gt;如果没有工厂的话，用户创建一个复杂的对象需要自己向对象的构造器传递一堆复杂的参数，或者是请求一个默认构造器，然后根据“说明书”一步步地设置各属性的值，或者还涉及创建其他对象。用户创建一个对象还要学习一些“专业知识”，我们当然希望用户的学习成本越低越好，同时可能也不希望这部分知识暴露给用户。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;工厂&lt;/code&gt;帮助用户创建复杂的对象。只需要告诉工厂需要什么样的对象，就可以得到一个默认的合法对象。&lt;/p&gt;
&lt;p&gt;在GOF的著作《设计模式》中，实现工厂的模式有：简单工厂模式、工厂方法模式和抽象工厂模式。&lt;/p&gt;
&lt;h4 id=&quot;资源库（Repositories）&quot;&gt;&lt;a href=&quot;#资源库（Repositories）&quot; class=&quot;headerlink&quot; title=&quot;资源库（Repositories）&quot;&gt;&lt;/a&gt;资源库（Repositories）&lt;/h4&gt;&lt;p&gt;&lt;code&gt;资源库&lt;/code&gt;提供一个渠道来让用户获取领域对象，它封装了所有获取对象所需要的逻辑。领域对象不需要与基础设施交互就能获取其他对象。&lt;/p&gt;
&lt;p&gt;如果没有资源库，其他对象获取某个对象时可能就直接与基础设施交互（如数据库），这破坏了领域层的专注性和封装性。&lt;/p&gt;
&lt;p&gt;资源库本身保存对象的引用，如果查询时资源库还没有保存这个对象，那么资源库就去基础设施中获取后再保存好。&lt;/p&gt;
&lt;p&gt;另外，资源库还可以控制对象的生命周期。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;业务开发往往是为了解决真实世界中某个业务领域的具体问题，它的复杂性大多时候也取决于业务的复杂性。如何开发一个可维护的复杂业务的软件？本书提供了一种叫做&lt;code&gt;领域驱动设计&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Domain%20Driven%20Design&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="领域驱动设计" scheme="http://blog.abandonzhang.me/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 存储引擎源码学习 —— 存储管理</title>
    <link href="http://blog.abandonzhang.me/2016/10/29/InnoDB-Src-Storage/"/>
    <id>http://blog.abandonzhang.me/2016/10/29/InnoDB-Src-Storage/</id>
    <published>2016-10-29T04:03:56.000Z</published>
    <updated>2018-01-21T10:14:19.668Z</updated>
    
    <content type="html">&lt;h2 id=&quot;存储层次&quot;&gt;&lt;a href=&quot;#存储层次&quot; class=&quot;headerlink&quot; title=&quot;存储层次&quot;&gt;&lt;/a&gt;存储层次&lt;/h2&gt;&lt;p&gt;InnoDB 实现的表空间 (table space) 是在文件系统之上又构建的一层逻辑存储的空间管理，每个表空间在逻辑上划分为了如下的几层结构，依次包括：table space（表空间）、segment（段）、extent（区）、page（页）、record（记录）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/InnoDB_Space_Management.png?imageMogr2/thumbnail/!40p&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;页（Page）&quot;&gt;&lt;a href=&quot;#页（Page）&quot; class=&quot;headerlink&quot; title=&quot;页（Page）&quot;&gt;&lt;/a&gt;页（Page）&lt;/h2&gt;&lt;p&gt;页是 InnoDB 中最小的物理存储和读写单位，大小由宏UNIV_PAGE_SIZE指定，默认是16K。&lt;br&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/univ.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; UNIV_PAGE_SIZE      ((ulint) srv_page_size)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt;    srv_page_size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** srv/srv0srv.cc */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UNIV_INTERN &lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt;   srv_page_size       = UNIV_PAGE_SIZE_DEF;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;页的结构&quot;&gt;&lt;a href=&quot;#页的结构&quot; class=&quot;headerlink&quot; title=&quot;页的结构&quot;&gt;&lt;/a&gt;页的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Basic_Page_Overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面的宏定义了页的头部中各个数据的偏移量：&lt;br&gt;&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fil0fil.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Header&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_SPACE_OR_CHKSUM    0  # 对于大于4.0.14的版本，存储的为&lt;span class=&quot;meta-keyword&quot;&gt;checksum&lt;/span&gt;；否则为0（小于4.0.14版本中的space id）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_OFFSET             4  # 页在表空间中的偏移量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_PREV               8  # 前一页在表空间中的偏移量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_NEXT               12 # 后一页在表空间中的偏移量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_LSN                16 # 页最近一次flush到磁盘时的redo log lsn（日志序列号）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE               24 # 页类型page type，同样也在该头文件中宏定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_FILE_FLUSH_LSN     26 # 页被flush到磁盘中的lsn &amp;gt;= 该lsn。仅在系统表空间的第一页中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_SPACE_ID           34 # 页所在表空间id（或页最近一次归档的archive log lsn）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_DATA               38 # 从第38个字节开始就是数据部分了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Trailer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_END_LSN_OLD_CHKSUM 8  # 倒数的偏移量。最后8字节中，最后4个字节是FIL_PAGE_LSN的低4位，用来check页是否写完整了；高4位是旧版的checknum&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不同类型的页对应data部分的数据结构是不同的，因此需要根据header中的页类型来解析该页的数据。&lt;/p&gt;
&lt;p&gt;Innodb定义了以下几种页（FIL_PAGE_TYPE的值）：&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fil0fil.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** File page types (values of FIL_PAGE_TYPE) @&amp;#123; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_INDEX                  17855   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; B-tree node */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_UNDO_LOG               2   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Undo log page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_INODE                  3   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Index node */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_IBUF_FREE_LIST         4   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Insert buffer free list */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* File page types introduced in MySQL/InnoDB 5.1.7 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_ALLOCATED         0   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Freshly allocated page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_IBUF_BITMAP            5   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Insert buffer bitmap */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_SYS               6   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; System page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_TRX_SYS           7   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Transaction system data */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_FSP_HDR           8   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; File space header */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_XDES              9   &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Extent descriptor page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_BLOB              10  &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Uncompressed BLOB page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_ZBLOB             11  &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; First compressed BLOB page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_ZBLOB2            12  &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Subsequent compressed BLOB page */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FIL_PAGE_TYPE_LAST              FIL_PAGE_TYPE_ZBLOB2    &lt;span class=&quot;comment&quot;&gt;/*!&amp;lt; Last page type */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* @&amp;#125; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;区（Extent）&quot;&gt;&lt;a href=&quot;#区（Extent）&quot; class=&quot;headerlink&quot; title=&quot;区（Extent）&quot;&gt;&lt;/a&gt;区（Extent）&lt;/h2&gt;&lt;p&gt;在页之上，Innodb还引入了“区”的存储结构，为了提高空间申请的效率和数据存放的顺序性。（若数据根据键值顺序存储，则在遍历数据的时候可以减小磁头旋转定位带来的时间开销）&lt;/p&gt;
&lt;p&gt;宏FSP_EXTENT_SIZE定义了一个区可以管理多少页。&lt;br&gt;&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/** Percona Server 5.7.15: include/fil0fil.h &lt;span class=&quot;strong&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;/** File space extent size in pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;page size | file space extent size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------+-----------------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;   4 KiB  | 256 pages = 1 MiB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;   8 KiB  | 128 pages = 1 MiB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;  16 KiB  |  64 pages = 1 MiB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;  32 KiB  |  64 pages = 2 MiB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;code&quot;&gt;  64 KiB  |  64 pages = 4 MiB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;strong&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define FSP_EXTENT_SIZE         ((UNIV_PAGE_SIZE &amp;lt;= (16384) ?   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (1048576 / UNIV_PAGE_SIZE) :    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ((UNIV_PAGE_SIZE &amp;lt;= (32768)) ?  \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (2097152 / UNIV_PAGE_SIZE) :    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (4194304 / UNIV_PAGE_SIZE))))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;区的体现主要就在“区描述符”（Extent Descriptors）这个数据结构上。&lt;/p&gt;
&lt;h3 id=&quot;区描述符的结构&quot;&gt;&lt;a href=&quot;#区描述符的结构&quot; class=&quot;headerlink&quot; title=&quot;区描述符的结构&quot;&gt;&lt;/a&gt;区描述符的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/XDES_Entry.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面的宏定义的是区描述符各个信息的偏移量：&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fsp0fsp.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; XDES_ID             0                       # 区所属段ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; XDES_FLST_NODE      8                       # 区描述符所在的list node数据结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; XDES_STATE          (FLST_NODE_SIZE + 8)    # 区的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; XDES_BITMAP         (FLST_NODE_SIZE + 12)   # 该区内各页是否被使用bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;区描述符的大小是算出来的（默认是40KiB）：&lt;br&gt;&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/** MySQL &lt;span class=&quot;number&quot;&gt;5.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.34&lt;/span&gt;: include/fsp0fsp.h */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define XDES_SIZE           (XDES_BITMAP + UT_BITS_IN_BYTES(FSP_EXTENT_SIZE * XDES_BITS_PER_PAGE))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 区描述符大小 = &lt;span class=&quot;keyword&quot;&gt;Byte&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;File&lt;/span&gt; Seg ID) + &lt;span class=&quot;keyword&quot;&gt;Byte&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;List&lt;/span&gt; Node) + &lt;span class=&quot;keyword&quot;&gt;Byte&lt;/span&gt;(State) + &lt;span class=&quot;keyword&quot;&gt;Byte&lt;/span&gt;(一个区能管理的页数*每页bitmap所需Bit数)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Innodb定义了一个页可以保存256个区描述符。保存区描述符的页类型为FIL_PAGE_TYPE_XDES，即区描述符页。&lt;/p&gt;
&lt;h3 id=&quot;区描述符页的结构&quot;&gt;&lt;a href=&quot;#区描述符页的结构&quot; class=&quot;headerlink&quot; title=&quot;区描述符页的结构&quot;&gt;&lt;/a&gt;区描述符页的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/FSP_HDR_Page_Overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里有个特殊情况是，在表空间的第一页，有一个Space Header的数据结构负责管理整个表空间内的页、区和段。因此第一页类型为FIL_PAGE_TYPE_FSP_HDR。但同时这一页也是区描述符页，提供接下来256个区的区描述符。&lt;/p&gt;
&lt;h2 id=&quot;段（Segment）&quot;&gt;&lt;a href=&quot;#段（Segment）&quot; class=&quot;headerlink&quot; title=&quot;段（Segment）&quot;&gt;&lt;/a&gt;段（Segment）&lt;/h2&gt;&lt;p&gt;段用来保存和管理特定对象的数据。对于Innodb存储引擎而言，表是最常见的对象。在Innodb中，表中的数据都是根据主键值以B+树索引的方式组织的，因此在Innodb的设计中，每张用户表至少有两个段，B+树索引的叶子节点段和非叶子节点段。&lt;/p&gt;
&lt;p&gt;段的体现主要就在Inode（全称：File Segment Inode）这个数据结构上。&lt;/p&gt;
&lt;h3 id=&quot;Inode的结构&quot;&gt;&lt;a href=&quot;#Inode的结构&quot; class=&quot;headerlink&quot; title=&quot;Inode的结构&quot;&gt;&lt;/a&gt;Inode的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/INODE_Entry.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面的宏定义了Inode各个信息的偏移量：&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fsp0fsp.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_ID                 0                               # 段ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_NOT_FULL_N_USED    8                               # 在部分空闲的区中已使用的页数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_FREE               12                              # 完全空闲的区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_NOT_FULL           (12 + FLST_BASE_NODE_SIZE)      # 部分空闲的区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_FULL               (12 + 2 * FLST_BASE_NODE_SIZE)  # 已经使用满的区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_MAGIC_N            (12 + 3 * FLST_BASE_NODE_SIZE)  # debug模式用的magic number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_FRAG_ARR           (16 + 3 * FLST_BASE_NODE_SIZE)  # 碎片页Slot&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有的对象非常小，不需要一个完整的区来保存数据。为了节省空间（留下更多的区给其他段用），Innodb对于每个段都设计了碎片页来保存小数据。&lt;/p&gt;
&lt;p&gt;Innodb的设计是：从创建表开始，随着数据的增加，段每次从表空间中获取一个页；当已经获取了足够多碎片页后，开始每次申请一个区。&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fsp0fsp.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_FRAG_ARR_N_SLOTS   (FSP_EXTENT_SIZE / 2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可以看到这里设定的是每个段可以有一个区可以管理页数一半的碎片页&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSEG_FRAG_SLOT_SIZE 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义每个碎片页Slot的大小，实际Slot记录了页在表空间中的偏移量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Inode的大小也是算出来的：&lt;br&gt;&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; MySQL 5.6.34: include/fsp0fsp.h &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#define FSEG_INODE_SIZE     (16 + 3 * FLST_BASE_NODE_SIZE + FSEG_FRAG_ARR_N_SLOTS * FSEG_FRAG_SLOT_SIZE)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;专门存放Inode的页类型为FIL_PAGE_INODE：&lt;/p&gt;
&lt;h3 id=&quot;Inode页的结构&quot;&gt;&lt;a href=&quot;#Inode页的结构&quot; class=&quot;headerlink&quot; title=&quot;Inode页的结构&quot;&gt;&lt;/a&gt;Inode页的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/INODE_Page_Overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;表空间（Table-Space）&quot;&gt;&lt;a href=&quot;#表空间（Table-Space）&quot; class=&quot;headerlink&quot; title=&quot;表空间（Table Space）&quot;&gt;&lt;/a&gt;表空间（Table Space）&lt;/h2&gt;&lt;p&gt;表空间负责管理空间内的页、区和段。&lt;/p&gt;
&lt;p&gt;默认所有用户表都在一个表空间（共享表空间）中，可以通过配置innodb_file_per_table指定每个表的数据和索引都在自己的独立表空间中。&lt;/p&gt;
&lt;p&gt;表空间的体现主要就在Space Header这个数据结构上。&lt;/p&gt;
&lt;h3 id=&quot;Space-Header的结构&quot;&gt;&lt;a href=&quot;#Space-Header的结构&quot; class=&quot;headerlink&quot; title=&quot;Space Header的结构&quot;&gt;&lt;/a&gt;Space Header的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/FSP_Header.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** MySQL 5.6.34: include/fsp0fsp.h */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SPACE_ID        0                               # 表空间ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_NOT_USED        4                               # 未使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SIZE            8                               #&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_FREE_LIMIT      12                              # 当前已经初始化好的页偏移量（后面的空间都是没有初始化的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SPACE_FLAGS     16                              #&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_FRAG_N_USED     20                              # 碎片区中已经使用的页的总数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_FREE            24                              # 空闲区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_FREE_FRAG       (24 + FLST_BASE_NODE_SIZE)      # 空闲碎片区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_FULL_FRAG       (24 + 2 * FLST_BASE_NODE_SIZE)  # 已经完全使用的碎片区链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SEG_ID          (24 + 3 * FLST_BASE_NODE_SIZE)  # 下一个段的ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SEG_INODES_FULL (32 + 3 * FLST_BASE_NODE_SIZE)  # 已经占满Inode的Inode页&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; FSP_SEG_INODES_FREE (32 + 4 * FLST_BASE_NODE_SIZE)  # 没有占满Inode的Inode页&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有一个&lt;code&gt;碎片区&lt;/code&gt;的概念，是指包含区描述符页的区，不能分配给段使用。&lt;/p&gt;
&lt;h3 id=&quot;表空间的结构&quot;&gt;&lt;a href=&quot;#表空间的结构&quot; class=&quot;headerlink&quot; title=&quot;表空间的结构&quot;&gt;&lt;/a&gt;表空间的结构&lt;/h3&gt;&lt;p&gt;整个表空间的存储结构看起来是下面这个样子的（以页为单位）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/Space_File_Overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;表空间全景&quot;&gt;&lt;a href=&quot;#表空间全景&quot; class=&quot;headerlink&quot; title=&quot;表空间全景&quot;&gt;&lt;/a&gt;表空间全景&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/InnoDB_Table_Space&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;&lt;a href=&quot;#推荐阅读&quot; class=&quot;headerlink&quot; title=&quot;推荐阅读&quot;&gt;&lt;/a&gt;推荐阅读&lt;/h2&gt;&lt;p&gt;1.&lt;a href=&quot;http://mysql.taobao.org/monthly/2016/02/01/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MySQL · 引擎特性 · InnoDB 文件系统之文件物理结构&lt;/a&gt;&lt;br&gt;2.&lt;a href=&quot;https://jin-yang.github.io/post/mysql-innodb-storage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;InnoDB 存储空间-理论&lt;/a&gt;&lt;br&gt;3.&lt;a href=&quot;https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jeremy Cole: Page management in InnoDB space files&lt;/a&gt;&lt;br&gt;4.&lt;a href=&quot;https://blog.jcole.us/innodb/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jeremy Cole: InnoDB文章合集&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存储层次&quot;&gt;&lt;a href=&quot;#存储层次&quot; class=&quot;headerlink&quot; title=&quot;存储层次&quot;&gt;&lt;/a&gt;存储层次&lt;/h2&gt;&lt;p&gt;InnoDB 实现的表空间 (table space) 是在文件系统之上又构建的一层逻辑存储的空间管理，每个表空间在逻辑上划分为了如下的几层结构，依次包括：table space（表空间）、segment（段）、extent（区）、page（页）、record（记录）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/InnoDB_Space_Management.png?imageMogr2/thumbnail/!40p&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.abandonzhang.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统：指令集架构、汇编语言与高级程序语言特性</title>
    <link href="http://blog.abandonzhang.me/2016/05/29/CSAPP-ISA-Assembly/"/>
    <id>http://blog.abandonzhang.me/2016/05/29/CSAPP-ISA-Assembly/</id>
    <published>2016-05-29T11:01:57.000Z</published>
    <updated>2018-01-21T10:25:58.642Z</updated>
    
    <content type="html">&lt;p&gt;CSAPP &amp;amp;&amp;amp; CMU 15-213 &lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-m15/www/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intro to Computer Systems&lt;/a&gt; 学习笔记（一）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是计算机&quot;&gt;&lt;a href=&quot;#什么是计算机&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机&quot;&gt;&lt;/a&gt;什么是计算机&lt;/h2&gt;&lt;p&gt;计算机本质上就是一个可以接受输入数据，执行特定指令，然后输出结果的电子设备。&lt;/p&gt;
&lt;h3 id=&quot;信息的传输&quot;&gt;&lt;a href=&quot;#信息的传输&quot; class=&quot;headerlink&quot; title=&quot;信息的传输&quot;&gt;&lt;/a&gt;信息的传输&lt;/h3&gt;&lt;p&gt;目前广泛应用的计算机都还是电子计算机，利用数字电路传输和存储信息[1]。考虑到电子器件间通过电路传递信息的可靠性和稳定性，计算机中的信息都是以二进制的形式存在的，低电压是0，高电压是1。一个0或1就叫一个&lt;code&gt;Bit&lt;/code&gt;，类似现实世界中的原子，构成计算机中的万物。&lt;/p&gt;
&lt;h3 id=&quot;输入输出设备&quot;&gt;&lt;a href=&quot;#输入输出设备&quot; class=&quot;headerlink&quot; title=&quot;输入输出设备&quot;&gt;&lt;/a&gt;输入输出设备&lt;/h3&gt;&lt;p&gt;早期的输入输出（Input Output，IO）设备就是穿孔纸带，带孔为1，无孔为0。工程师们将纸带打好洞传给计算机的卡片阅读器，然后计算机输出的时候则用打卡器将纸带打好洞传给工程师。后来就有了各种各样的IO设备，键盘、鼠标、显示器、耳机等……&lt;/p&gt;
&lt;p&gt;每一种设备与计算机之间都需要一个&lt;code&gt;驱动程序&lt;/code&gt;，负责当设备和计算机之间的“翻译”。比如上面提到的卡片阅读器和打卡器，就是纸带的驱动程序。卡片阅读器把纸带的打孔状态翻译成计算机能够理解的二进制电流，打卡器相反把计算机的电流反映到纸带的打孔状态上。&lt;/p&gt;
&lt;h3 id=&quot;计算机系统结构&quot;&gt;&lt;a href=&quot;#计算机系统结构&quot; class=&quot;headerlink&quot; title=&quot;计算机系统结构&quot;&gt;&lt;/a&gt;计算机系统结构&lt;/h3&gt;&lt;p&gt;有了数据和输入输出设备，计算机内部又是怎么把他们串起来变成一个系统的呢，指令、计算又是如何执行的呢？&lt;/p&gt;
&lt;p&gt;计算机软硬件中间层各个部分的功能、组织和实现的设计被称为&lt;code&gt;计算机系统结构&lt;/code&gt;（Computer Architecture），主要包括：指令集架构、微架构和实现。&lt;/p&gt;
&lt;p&gt;以常见的冯·诺伊曼结构的设计为例：&lt;br&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/CSAPP_ISAE91427A6-77A9-4BE9-8CD3-D1112170827B.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;计算机大致由这几部分组成：处理器（Processer）、内存（Memory）、IO设备、总线（Bus）。其中，处理器是集中央控制和计算功能于一身的最重要的部分，总线则负责处理器与内存、IO设备之间的通信。&lt;/p&gt;
&lt;p&gt;与另一个著名的哈佛结构的计算机相比，冯·诺依曼结构的计算机将指令和数据放在一起，程序执行时会把它们从IO设备读取到一个内存区域中。&lt;/p&gt;
&lt;p&gt;计算机系统结构的设计主要就是处理器的设计。&lt;/p&gt;
&lt;h4 id=&quot;指令集架构&quot;&gt;&lt;a href=&quot;#指令集架构&quot; class=&quot;headerlink&quot; title=&quot;指令集架构&quot;&gt;&lt;/a&gt;指令集架构&lt;/h4&gt;&lt;p&gt;处理器可执行的指令集是预先设定好的。设计时除了要考虑要实现哪些计算，还要考虑指令格式、占位，数据存在哪里、怎么存（寄存器、内存），如何获取数据（寻址方式）等，这些方面合在一起就是&lt;code&gt;指令集架构&lt;/code&gt;（Instruction Set Architecture）的设计。&lt;/p&gt;
&lt;p&gt;传统的指令集架构设计被称为&lt;code&gt;复杂指令集计算机&lt;/code&gt;（Complex Instruction Set Computer）。那时候硬件水平比较低，内存容量小，大家都尽量让程序的指令数少一点，写程序也简单一点，同时也为了一些计算的性能提升，不断把一些复杂的计算用硬件实现成一条指令加入到指令集中。但这样又带来了其他问题：指令集越来越庞大，指令长度不统一、解析速度慢，指令周期不一致、难以流水线化（pipeline），硬件成本提高。代表有Intel的IA32和Intel®64（又名x86-64、x64，实际上x64是AMD先推出的，所以也有AMD64）。&lt;/p&gt;
&lt;p&gt;1980年出现了一种新的指令集体系的设计理念&lt;code&gt;精简指令集计算机&lt;/code&gt;（Reduced Instruction Set Computer），基于80%的功能都是由20%的指令完成的“二八原则”，对指令集做了精简：统一的指令长度和指令周期，便于指令的流水线化；处理器实现更加简单，成本和功耗更低。目前广泛应用于智能手机的ARM处理器就是RISC架构，另外比较有名的还有MIPS。实际上Intel的x86处理器也借鉴了RISC的思想，指令在进入流水线前会被分解成微指令来执行。&lt;/p&gt;
&lt;p&gt;为什么Intel没有从CISC转投RISC呢？这其实是一场商业与技术博弈的结果[2]：为了每代处理器的向前兼容性，Intel是无法完全抛弃CISC的。实际上当时Intel是有另一个项目组在搞RISC处理器的，只是搞出来之后无法被市场所接受（因为之前的软件无法在新处理器上运行）。这也提醒我们搞技术的同学，不要总是单纯以技术的眼光来看待问题。&lt;/p&gt;
&lt;p&gt;HPCA13的一篇论文[3]分析得出了ISA的选择对现代处理器性能和功耗的影响是无关紧要的，影响更多的是处理器的制造工艺和微架构。&lt;/p&gt;
&lt;h4 id=&quot;微架构&quot;&gt;&lt;a href=&quot;#微架构&quot; class=&quot;headerlink&quot; title=&quot;微架构&quot;&gt;&lt;/a&gt;微架构&lt;/h4&gt;&lt;p&gt;指令集架构决定了处理器的架构和设计，而&lt;code&gt;微架构&lt;/code&gt;（Microarchitecture）则决定了处理器如何实现指令集架构。这个实现不是指的硬件上的实现，而是更细分的逻辑部件和各部件之间如何沟通合作的设计，这里不再展开。Intel处理器的微架构有：Sandy Bridge、Ivy Bridge、Haswell、Skylake等。&lt;/p&gt;
&lt;h2 id=&quot;汇编语言&quot;&gt;&lt;a href=&quot;#汇编语言&quot; class=&quot;headerlink&quot; title=&quot;汇编语言&quot;&gt;&lt;/a&gt;汇编语言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;汇编语言&lt;/code&gt;（Assembly Language）就是将01形式的机器指令“翻译”成了我们方便阅读的英文符号。&lt;code&gt;汇编器&lt;/code&gt;（Assembler）可以将我们写的汇编语言程序转换成机器指令。&lt;/p&gt;
&lt;p&gt;两大公司Intel和AT&amp;amp;T开发的汇编器分别被Windows系统和Unix/Linux系统广泛应用，造就了目前最常用的两种汇编语法。当然两种汇编在语法上只有细微的差别，不需要重复学习。&lt;/p&gt;
&lt;p&gt;下面我们就以AT&amp;amp;T汇编为例来学习Intel的的IA32指令集架构[4]。&lt;/p&gt;
&lt;h3 id=&quot;IA32处理器结构&quot;&gt;&lt;a href=&quot;#IA32处理器结构&quot; class=&quot;headerlink&quot; title=&quot;IA32处理器结构&quot;&gt;&lt;/a&gt;IA32处理器结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://abandonzhang-blog-pictures.qiniudn.com/CSAPP_ISA14498EF0-8DE8-41E0-B4D8-961A725FE4C8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如图所示，IA32的处理器的部件包括：控制单元、执行单元（算数逻辑单元）、寄存器和标记位（这方面x86也一样）。各个部分的延伸可以去看[4]，这里不再展开。&lt;/p&gt;
&lt;h2 id=&quot;推荐资料&quot;&gt;&lt;a href=&quot;#推荐资料&quot; class=&quot;headerlink&quot; title=&quot;推荐资料&quot;&gt;&lt;/a&gt;推荐资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;《编码：隐匿在计算机软硬件背后的语言》&lt;/li&gt;
&lt;li&gt;《浪潮之巅》&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Power Struggles: Revisiting the RISC vs. CISC Debate on Contemporary ARM and x86 Architectures&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Professional Assembly Language&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CSAPP &amp;amp;&amp;amp; CMU 15-213 &lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-m15/www/&quot;&gt;Intro to Computer Systems&lt;/a&gt; 学习笔记（一）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机系统结构" scheme="http://blog.abandonzhang.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>密码管理软件推荐</title>
    <link href="http://blog.abandonzhang.me/2016/05/08/KeePassX/"/>
    <id>http://blog.abandonzhang.me/2016/05/08/KeePassX/</id>
    <published>2016-05-08T08:16:42.000Z</published>
    <updated>2018-01-21T10:14:19.674Z</updated>
    
    <content type="html">&lt;p&gt;LastPass、KeePass、1Password，个人喜好程度由低到高。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;LastPass&quot;&gt;&lt;a href=&quot;#LastPass&quot; class=&quot;headerlink&quot; title=&quot;LastPass&quot;&gt;&lt;/a&gt;LastPass&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://lastpass.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LastPass&lt;/a&gt;本质上是一个Web服务，密码是存储在LastPass的服务器上的。&lt;/p&gt;
&lt;p&gt;虽说密码在服务器上也不是明文保存，而是JavaScript在本地生成一个密钥后经过AES256对称加密后再上传到服务器上（用户查看密码时也是在本地JavaScript解密显示）。不过这个密钥放在哪里，安全性怎么样呢我也不知道……而且万一服务器数据丢失了呢……&lt;/p&gt;
&lt;p&gt;它通过安装多种浏览器的插件来提供自动填充和离线密码查看功能，嗯……感觉有点像把各浏览器自带的密码工具集合起来的意思呢……&lt;/p&gt;
&lt;h2 id=&quot;KeePass&quot;&gt;&lt;a href=&quot;#KeePass&quot; class=&quot;headerlink&quot; title=&quot;KeePass&quot;&gt;&lt;/a&gt;KeePass&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://keepass.info/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KeePass&lt;/a&gt;是一个免费的本地密码管理软件，最新版是KeePass2，不支持浏览器自动填充。缺点是界面不太好看，而且原生的KeePass2在OS X上安装太麻烦了。&lt;/p&gt;
&lt;p&gt;幸运的是因为KeePass是开源的，所以也涌现了很多基于KeePass的第三方跨平台的软件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.keepassx.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;KeePassX&lt;/a&gt;就是一个很优秀的第三方软件，支持KeePass2的.kdbx加密文件。所以同时有OS X和Windows设备的人完全可以在OS X下用KeePassX，在Windows下用原生的KeePass2，然后把kdbx文件放在云盘上同步。对于没钱买1Password的人来说还算是个不错的选择哦~&lt;/p&gt;
&lt;h2 id=&quot;1Password&quot;&gt;&lt;a href=&quot;#1Password&quot; class=&quot;headerlink&quot; title=&quot;1Password&quot;&gt;&lt;/a&gt;1Password&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://agilebits.com/onepassword&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1password&lt;/a&gt;就很厉害了，目前公认的最好的密码管理软件。本地加密存储，可以同步到服务器跨设备使用，支持浏览器自动填充。&lt;/p&gt;
&lt;p&gt;缺点就是太贵了——65刀_(:зゝ∠)_，不过包括了OS X、Windows、IOS和Android版，有钱的话推荐。&lt;/p&gt;
&lt;p&gt;另外听说有时候它的浏览器自动填充功能不太好使。But, who care？我就是想存个密码而已嘛！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;LastPass、KeePass、1Password，个人喜好程度由低到高。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://blog.abandonzhang.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的正则表达式</title>
    <link href="http://blog.abandonzhang.me/2016/01/05/Regexes/"/>
    <id>http://blog.abandonzhang.me/2016/01/05/Regexes/</id>
    <published>2016-01-05T09:25:03.000Z</published>
    <updated>2018-01-21T10:14:19.664Z</updated>
    
    <content type="html">&lt;p&gt;正则表达式（Regular Expression）本是一个理论计算机科学中的概念，在1950年代Stephen Kleene为了形式化地描述正则语言而提出它。今天主要介绍一下在编程语言中经常提到的“正则表达式”，它们的概念是不同的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;“Regexes”&quot;&gt;&lt;a href=&quot;#“Regexes”&quot; class=&quot;headerlink&quot; title=&quot;“Regexes”&quot;&gt;&lt;/a&gt;“Regexes”&lt;/h2&gt;&lt;p&gt;很多编程语言中都有实现自己的“正则表达式”引擎来做模式匹配：Perl的Regexes，C++、C#、Java的regex、Javascript的RegExp…事实上，这些模式匹配库所能表达的语言范畴已经大大超出了理论上的正则语言，甚至超出了上下文无关语言的范畴。Perl之父Larry Wall曾在一篇讨论Perl6的文章中说道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘Regular expressions’ are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I’m not going to try to fight linguistic necessity here. I will, however, generally call them “regexes”.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面开始正式讨论编程语言中的正则表达式。为了方便，下文中就直接使用正则表达式的说法了。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式语法&quot;&gt;&lt;a href=&quot;#正则表达式语法&quot; class=&quot;headerlink&quot; title=&quot;正则表达式语法&quot;&gt;&lt;/a&gt;正则表达式语法&lt;/h2&gt;&lt;p&gt;正则表达式一般以正斜杠&lt;code&gt;/&lt;/code&gt;开头和结尾，格式形如：&lt;code&gt;/expression/&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;普通字符&quot;&gt;&lt;a href=&quot;#普通字符&quot; class=&quot;headerlink&quot; title=&quot;普通字符&quot;&gt;&lt;/a&gt;普通字符&lt;/h3&gt;&lt;p&gt;最简单的正则表达式就是普通的字符串&lt;code&gt;/string/&lt;/code&gt;，这种情况下的正则匹配就是简单的字符串匹配。如&lt;code&gt;/abc/&lt;/code&gt;可以匹配abcd、1abcde等等。&lt;/p&gt;
&lt;h3 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h3&gt;&lt;p&gt;元字符是正则表达式指定的表达特殊含义的一些字符，可以组合普通字符使用以实现强大的模式匹配功能。下表列出了&lt;code&gt;GNU ERE&lt;/code&gt;标准的元字符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;行为&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;将下一个字符标记为一个转义字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;表示换行符，&lt;code&gt;\\&lt;/code&gt;表示真正的反斜杠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配字符串的开始位置&lt;/td&gt;
&lt;td&gt;^abc表示以abc开头的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配字符串的结束位置&lt;/td&gt;
&lt;td&gt;xyz$表示以xyz结尾的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配任意一个字符（有些标准会排除\n）&lt;/td&gt;
&lt;td&gt;^.*$就表示匹配任意一行字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;0次或多次匹配子串&lt;/td&gt;
&lt;td&gt;a(bc)*可以匹配a,abc,abcbc,…等字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;1次或多次匹配子串&lt;/td&gt;
&lt;td&gt;a+等价于aa*。a(bc)+可以匹配abc,abcbc,…等字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;0次或1次匹配子串&lt;/td&gt;
&lt;td&gt;a(bc)?可以匹配a和abc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;brvbar;&lt;/td&gt;
&lt;td&gt;指定在两个或多个模式之间选择&lt;/td&gt;
&lt;td&gt;z&amp;brvbar;food匹配z或者food&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(…)&lt;/td&gt;
&lt;td&gt;标记子表达式并获取匹配到的子字符串，可以通过\1，\2的方式在后面使用它&lt;/td&gt;
&lt;td&gt;^(o{1,})k\1$可以匹配oko,ookoo,…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[…]&lt;/td&gt;
&lt;td&gt;标记一个字符集，可以匹配其中的任何一个字符&lt;br&gt;（字符集中的元字符没有特殊含义）&lt;/td&gt;
&lt;td&gt;[abc]表示可以匹配a或b或c；[a-z]表示可以匹配所有小写字母；[a-zA-Z]表示可以匹配所有字母；[*]表示匹配*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^…]&lt;/td&gt;
&lt;td&gt;标记一个反字符集，表示除了其中的字符外其它字符都可以匹配&lt;/td&gt;
&lt;td&gt;[^a-z]表示除了小写字母其它都匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;n次匹配子串&lt;/td&gt;
&lt;td&gt;o{2}可以匹配book、foot，但不能匹配Bob。&lt;br&gt;（o{2}也可以匹配goooooal，只是本次匹配只占用前两个o）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{min,}&lt;/td&gt;
&lt;td&gt;至少min次匹配子串&lt;/td&gt;
&lt;td&gt;o{1,}等价于o+，o{0,}等价于o*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{min,max}&lt;/td&gt;
&lt;td&gt;至少匹配min次，至多匹配max次子串&lt;/td&gt;
&lt;td&gt;o{0,1}等价于o?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;正则表达式的POSIX标准&quot;&gt;&lt;a href=&quot;#正则表达式的POSIX标准&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的POSIX标准&quot;&gt;&lt;/a&gt;正则表达式的POSIX标准&lt;/h2&gt;&lt;h2 id=&quot;推荐资料&quot;&gt;&lt;a href=&quot;#推荐资料&quot; class=&quot;headerlink&quot; title=&quot;推荐资料&quot;&gt;&lt;/a&gt;推荐资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia - Regular Expression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux/Unix工具与正则表达式的POSIX规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;POSIX.1-2008 - Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://perl.plover.com/Regex/article.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How Regexes Work - 如何实现一个Regexes引擎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式（Regular Expression）本是一个理论计算机科学中的概念，在1950年代Stephen Kleene为了形式化地描述正则语言而提出它。今天主要介绍一下在编程语言中经常提到的“正则表达式”，它们的概念是不同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级编程语言特性" scheme="http://blog.abandonzhang.me/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>sed - 高效的文本替换语言</title>
    <link href="http://blog.abandonzhang.me/2016/01/03/Sed/"/>
    <id>http://blog.abandonzhang.me/2016/01/03/Sed/</id>
    <published>2016-01-03T09:03:45.000Z</published>
    <updated>2018-01-21T10:14:19.680Z</updated>
    
    <content type="html">&lt;p&gt;sed也是Linux/Unix下的一个文本处理工具（上次介绍了&lt;a href=&quot;http://blog.abandonzhang.me/2015/12/07/awk/&quot;&gt;awk&lt;/a&gt;），全称为stream editor，由Bell Labs在1974年发布。sed在它擅长的方面实现起来更加快速和简单，因此直到今天它还是一个很受欢迎的工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;How-sed-works&quot;&gt;&lt;a href=&quot;#How-sed-works&quot; class=&quot;headerlink&quot; title=&quot;How sed works&quot;&gt;&lt;/a&gt;How sed works&lt;/h2&gt;&lt;p&gt;sed程序以行为单位读入和处理文本，一个标准的sed处理过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从输入流（input stream）中读入一行数据，存入pattern space中。&lt;/li&gt;
&lt;li&gt;执行sed命令。sed的命令格式为[address]command，command前可以附加address来限制可以执行command的行。&lt;/li&gt;
&lt;li&gt;清空pattern space。在清空前，如果没有-n参数，则将pattern space中的内容输出到stdout（标准输出）。&lt;/li&gt;
&lt;li&gt;如果遇到EOF（文件末尾，或Linux环境标准输入的Ctrl-D信号）则退出，否则转到步骤1继续读取下一行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;address&quot;&gt;&lt;a href=&quot;#address&quot; class=&quot;headerlink&quot; title=&quot;address&quot;&gt;&lt;/a&gt;address&lt;/h2&gt;&lt;p&gt;address可以限制执行command的行，可以有以下形式（未全部列出）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;address&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;number[,number]&lt;/td&gt;
&lt;td&gt;第n行读入文本执行command；num1,num2表示第num1行到num2行之间的读入文本执行command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;最后一行读入文本执行command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/regexp/&lt;/td&gt;
&lt;td&gt;文本行正则匹配regexp时执行command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/regexp/I&lt;/td&gt;
&lt;td&gt;（GNU extension）同上，正则匹配时大小写不敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;接在address后，表示匹配到这个address的行不执行command&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果不指定address，则所有的读入行都执行command；指定address之后，只有匹配address的行才执行command。&lt;/p&gt;
&lt;h2 id=&quot;sed的文本替换命令s&quot;&gt;&lt;a href=&quot;#sed的文本替换命令s&quot; class=&quot;headerlink&quot; title=&quot;sed的文本替换命令s&quot;&gt;&lt;/a&gt;sed的文本替换命令s&lt;/h2&gt;&lt;p&gt;s是sed的文本替换命令，是sed中最重要和最常用的一个功能。其格式为：&lt;code&gt;s/regexp/replacement/flags&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;regexp是一个正则表达式，sed会将pattern space中的内容与regexp进行匹配，如果匹配则将pattern space中的内容替换为replacement。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flags指定了匹配和替换时的动作，常用的flag有（未全部列出）：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;flag&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;将pattern space中所有的匹配全部替换为replacement。（g前面加number时表示从第n个匹配才开始全部替换）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;如果替换动作发生，则输出replacement的内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;如果替换动作发生，则输出replacement的内容到file文件中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;（GNU extension）正则匹配时大小写不敏感。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有指定flag g，则只替换pattern space中的第一个匹配。如果flags前加number，则只替换第n个匹配。&lt;/li&gt;
&lt;li&gt;flag可以组合使用，且大部分情况下前后顺序不影响。如ig，gp，gw等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（Tips：看完后可以去后面做一下s命令相关的练习~）&lt;/p&gt;
&lt;h2 id=&quot;sed的其他命令&quot;&gt;&lt;a href=&quot;#sed的其他命令&quot; class=&quot;headerlink&quot; title=&quot;sed的其他命令&quot;&gt;&lt;/a&gt;sed的其他命令&lt;/h2&gt;&lt;p&gt;sed还有一些不太常用但是也比较有用的命令（未全部列出）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;command&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;y/source-chars/dest-chars/&lt;/td&gt;
&lt;td&gt;将pattern space中的source-char替换为dest-char；&lt;br&gt;source-chars长度与dest-chars必须相同，对应位置的source-char替换为对应位置的dest-char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a\text&lt;/td&gt;
&lt;td&gt;append。在pattern space后新一行追加text文本（文本中也可以通过\n转义符换行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;i\text&lt;/td&gt;
&lt;td&gt;insert。在pattern space前新一行插入text文本（文本中也可以通过\n转义符换行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;c\text&lt;/td&gt;
&lt;td&gt;将pattern space中的内容完全替换为test文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;在pattern space后新一行加入行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;r file&lt;/td&gt;
&lt;td&gt;从file读入文本追加到pattern space中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;w file&lt;/td&gt;
&lt;td&gt;将pattern space的内容写到file中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;清空pattern space的内容，立刻开始读入下一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;输出pattern space的内容（到stdout）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;将hold space中的内容替换为pattern space的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;在hold space后新一行追加pattern space的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;将pattern space中的内容替换为hold space的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;在pattern space后新一行追加hold space的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;互换pattern space和hold space的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;退出sed程序（如果-n参数时会先输出pattern space的内容）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PS：hold space是sed的一个辅助空间，不会自动填入，也不会自动清空。&lt;/p&gt;
&lt;h2 id=&quot;练习&quot;&gt;&lt;a href=&quot;#练习&quot; class=&quot;headerlink&quot; title=&quot;练习&quot;&gt;&lt;/a&gt;练习&lt;/h2&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;cat&lt;/span&gt; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;sed替换命令练习&quot;&gt;&lt;a href=&quot;#sed替换命令练习&quot; class=&quot;headerlink&quot; title=&quot;sed替换命令练习&quot;&gt;&lt;/a&gt;sed替换命令练习&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每行的one都替换为ten&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;s/&lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt;/ten/&lt;span class=&quot;keyword&quot;&gt;g&lt;/span&gt;&#39; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ten,ten,ten,ten&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ten,ten&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每行除了第一个one都替换为ten&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &lt;span class=&quot;string&quot;&gt;&#39;s/one/ten/2g&#39;&lt;/span&gt; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,ten,ten,ten&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,ten&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每行的第二个one替换为ten&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &lt;span class=&quot;string&quot;&gt;&#39;s/one/ten/2&#39;&lt;/span&gt; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,ten,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,ten&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三行的one替换为six&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;3s/&lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt;/six/&lt;span class=&quot;keyword&quot;&gt;g&lt;/span&gt;&#39; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// six,six&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二三行的one或two替换为six&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;2,3s/&lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt;\|&lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;/six/&lt;span class=&quot;keyword&quot;&gt;g&lt;/span&gt;&#39; demo	&lt;span class=&quot;comment&quot;&gt;// 这里正则表达式中的的|要转义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// six,six,six&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// six,six&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只有一个two的行，two替换为six&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;/^&lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;$/s/&lt;span class=&quot;keyword&quot;&gt;two&lt;/span&gt;/six/&lt;span class=&quot;keyword&quot;&gt;g&lt;/span&gt;&#39; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// six&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;sed其他命令练习&quot;&gt;&lt;a href=&quot;#sed其他命令练习&quot; class=&quot;headerlink&quot; title=&quot;sed其他命令练习&quot;&gt;&lt;/a&gt;sed其他命令练习&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除有one的行&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;/&lt;span class=&quot;keyword&quot;&gt;one&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;&#39; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在每行后面加一行’hello, world!’&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &lt;span class=&quot;string&quot;&gt;&#39;a\hello, world!&#39;&lt;/span&gt; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// hello, world!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// hello, world!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// hello, world!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// hello, world!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按行反序一个文件&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sed &#39;1!&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;h&lt;/span&gt;;$!&lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;&#39; demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// two,two,two,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// one,one,one,one&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;推荐资料&quot;&gt;&lt;a href=&quot;#推荐资料&quot; class=&quot;headerlink&quot; title=&quot;推荐资料&quot;&gt;&lt;/a&gt;推荐资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/sed/manual/sed.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sed, a stream editor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sed#Substitution_command&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia - sed&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;sed也是Linux/Unix下的一个文本处理工具（上次介绍了&lt;a href=&quot;http://blog.abandonzhang.me/2015/12/07/awk/&quot;&gt;awk&lt;/a&gt;），全称为stream editor，由Bell Labs在1974年发布。sed在它擅长的方面实现起来更加快速和简单，因此直到今天它还是一个很受欢迎的工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.abandonzhang.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>awk - 强大的文本处理语言</title>
    <link href="http://blog.abandonzhang.me/2015/12/06/Awk/"/>
    <id>http://blog.abandonzhang.me/2015/12/06/Awk/</id>
    <published>2015-12-06T08:14:55.000Z</published>
    <updated>2018-01-21T10:14:19.679Z</updated>
    
    <content type="html">&lt;p&gt;awk 是一个强大的文本处理语言，由贝尔实验室在1977年发布，名字取自它的三位创造者 Alfred Aho、Peter Weinberger 和 Brian Kernighan 名字的首字母。作为一个已经有38年历史的工具，awk 如今在文本处理中的地位仍然不可动摇，可称得上是一件上古神器了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;与 sed 相比，awk 的语法更加丰富和灵活，&lt;a href=&quot;https://en.wikipedia.org/wiki/AWK&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;它甚至是一种图灵完备的脚本语言&lt;/a&gt;。sed 可以实现的功能 awk 都可以实现。&lt;/p&gt;
&lt;h2 id=&quot;awk程序结构&quot;&gt;&lt;a href=&quot;#awk程序结构&quot; class=&quot;headerlink&quot; title=&quot;awk程序结构&quot;&gt;&lt;/a&gt;awk程序结构&lt;/h2&gt;&lt;p&gt;awk程序由一系列“pattern-action”模块组成：&lt;br&gt;&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* awk_file */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;pattern&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	action&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;pattern&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	action&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，pattern指定了awk程序可以执行它对应的action语句的条件，它可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BEGIN&lt;br&gt;该模块下的action将会在awk读取数据之前执行。&lt;/li&gt;
&lt;li&gt;END&lt;br&gt;该模块下的action将会在awk处理完所有数据之后执行。&lt;/li&gt;
&lt;li&gt;（关系or逻辑or正则）表达式&lt;br&gt;该模块下的action将会在当前记录满足表达式时执行。&lt;/li&gt;
&lt;li&gt;pattern1, pattern2 {action}&lt;br&gt;该模块下的action会在找到满足pattern1模式的记录时开始执行，在找到满足pattern2模式的记录后停止执行（满足pattern2模式的记录仍然会执行），即这两个记录之间的所有记录都会执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;How-awk-works&quot;&gt;&lt;a href=&quot;#How-awk-works&quot; class=&quot;headerlink&quot; title=&quot;How awk works&quot;&gt;&lt;/a&gt;How awk works&lt;/h2&gt;&lt;p&gt;awk程序以行为单位读入和处理文本，一个标准的awk处理过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从输入流中读入一行&lt;code&gt;记录&lt;/code&gt;（默认记录分隔符&lt;code&gt;RS&lt;/code&gt;为换行符），将其分割成若干个&lt;code&gt;字段&lt;/code&gt;（默认字段分隔符&lt;code&gt;FS&lt;/code&gt;为空格）。&lt;/li&gt;
&lt;li&gt;匹配每一个pattern，如果成功匹配pattern则执行它对应的action。&lt;/li&gt;
&lt;li&gt;如果遇到&lt;code&gt;EOF&lt;/code&gt;（文件末尾，或Linux环境标准输入的Ctrl-D信号）则退出，否则转到步骤1继续读取下一行记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;awk基本语法&quot;&gt;&lt;a href=&quot;#awk基本语法&quot; class=&quot;headerlink&quot; title=&quot;awk基本语法&quot;&gt;&lt;/a&gt;awk基本语法&lt;/h2&gt;&lt;p&gt;awk具备一个脚本语言该有的基本元素：变量、数组、函数、表达式、流程控制等。&lt;/p&gt;
&lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt;&lt;p&gt;awk可以像其他语言一样定义一个变量（无需显式定义类型），并且给它赋值，如：sum = 0。同时awk还有一些常用的内置变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;awk内置变量&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$0&lt;/td&gt;
&lt;td&gt;当前记录的整个内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$n&lt;/td&gt;
&lt;td&gt;n是一个整数，$n表示当前记录被分隔后的第n个字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FILENAME&lt;/td&gt;
&lt;td&gt;当前处理文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FS&lt;/td&gt;
&lt;td&gt;分隔符，FS = “:”效果等同于awk -F”:”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NF&lt;/td&gt;
&lt;td&gt;当前记录被分隔的字段数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NR&lt;/td&gt;
&lt;td&gt;当前记录的行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RS&lt;/td&gt;
&lt;td&gt;记录分隔符（默认是一个换行符）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OFS&lt;/td&gt;
&lt;td&gt;输出域分隔符，即分隔print命令的参数的符号。其默认值为空格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ORS&lt;/td&gt;
&lt;td&gt;输出记录分隔符，即每个print命令之间的符号。其默认值为换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OFMT&lt;/td&gt;
&lt;td&gt;数字的输出格式（默认是%.6g）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;练习：打印file文件第1~5行的倒数第二个字段&lt;br&gt;&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk &lt;span class=&quot;string&quot;&gt;&#39;NR==1, NR==5&amp;#123;print $(NF-1)&amp;#125;&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;p&gt;awk可以定义类似PHP的关联数组，且不必显示定义和初始化。数组的键值可以是整形，也可以是字符串。如：sum[0], sum[“test”]。&lt;/p&gt;
&lt;p&gt;虽然awk在存储上并不支持二维数组，但是它提供了逻辑上的访问方法。如sum[i, j] = 1是合法的。&lt;/p&gt;
&lt;h3 id=&quot;运算与表达式&quot;&gt;&lt;a href=&quot;#运算与表达式&quot; class=&quot;headerlink&quot; title=&quot;运算与表达式&quot;&gt;&lt;/a&gt;运算与表达式&lt;/h3&gt;&lt;p&gt;awk和其他高级程序设计语言一样支持多样的运算和表达式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算术运算符&lt;/td&gt;
&lt;td&gt;+ - * / %(取余) ^(幂) ++ --&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;赋值运算符&lt;/td&gt;
&lt;td&gt;= += -= *= /= %= ^=&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑运算符&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp; &amp;brvbar;&amp;brvbar; !&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关系运算符&lt;/td&gt;
&lt;td&gt;&amp;lt; &amp;gt; == != &amp;gt;= &amp;lt;=&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;正则运算符&lt;/td&gt;
&lt;td&gt;~ 表示匹配正则表达式，!~ 表示不匹配正则表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他运算符&lt;/td&gt;
&lt;td&gt;$，字段引用符； 空格，字符串连接符；?:，条件表达式；in，数组查找；etc…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;awk的表达式由换行或分号隔开。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;p&gt;awk定义函数以function开头，无需声明返回类型和参数类型，如下：&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add_one&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add_one(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;内置函数&quot;&gt;&lt;a href=&quot;#内置函数&quot; class=&quot;headerlink&quot; title=&quot;内置函数&quot;&gt;&lt;/a&gt;内置函数&lt;/h4&gt;&lt;p&gt;awk中有很多实用的内置函数，下面举几个常用的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;awk内置函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int(x)&lt;/td&gt;
&lt;td&gt;返回x的整数部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index(string1, string2)&lt;/td&gt;
&lt;td&gt;返回string2首次在string1中出现的位置，从1开始编号。没有出现返回0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length(string)&lt;/td&gt;
&lt;td&gt;返回string的字符长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blength(string)&lt;/td&gt;
&lt;td&gt;返回string的字节长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;substr(string, begin_pos, length)&lt;/td&gt;
&lt;td&gt;返回string的从begin_pos开始length长度的子字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;match(string, regEx)&lt;/td&gt;
&lt;td&gt;返回string首次匹配扩展正则表达式的位置，不匹配返回0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;split(string, A, [regEx])&lt;/td&gt;
&lt;td&gt;按照扩展正则表达式表示的分隔符将string分割成字段存储在A中。默认分隔符为FS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sprintf(format, expr, expr, …)&lt;/td&gt;
&lt;td&gt;格式化输出字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;systime()&lt;/td&gt;
&lt;td&gt;返回当前的UNIX时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;h4 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h4&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;if&lt;/span&gt; (expr1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;if&lt;/span&gt; (expr2)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h4&gt;&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for &lt;span class=&quot;comment&quot;&gt;(i = 0; i &amp;lt; NF; i ++)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for &lt;span class=&quot;comment&quot;&gt;(i in a)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;(i &amp;lt; NF)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;next语句&quot;&gt;&lt;a href=&quot;#next语句&quot; class=&quot;headerlink&quot; title=&quot;next语句&quot;&gt;&lt;/a&gt;next语句&lt;/h4&gt;&lt;p&gt;awk在流程控制方面除了有break、continue外，还有一个next语句，表示本条记录不进行之后的操作，直接开始读取和处理下一条记录。&lt;/p&gt;
&lt;h3 id=&quot;输出&quot;&gt;&lt;a href=&quot;#输出&quot; class=&quot;headerlink&quot; title=&quot;输出&quot;&gt;&lt;/a&gt;输出&lt;/h3&gt;&lt;h4 id=&quot;print-命令&quot;&gt;&lt;a href=&quot;#print-命令&quot; class=&quot;headerlink&quot; title=&quot;print 命令&quot;&gt;&lt;/a&gt;print 命令&lt;/h4&gt;&lt;p&gt;print命令可用于简单的输入文本。print后可带多个变量，以”,”逗号隔开。awk将按顺序打印，并以”输出记录分隔符”(ORS)分割的，默认为换行符，我们可以通过给ORS赋值来控制输出字段的分隔符。&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print $1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print $2, $3, $4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print add_one(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;printf-格式化输出&quot;&gt;&lt;a href=&quot;#printf-格式化输出&quot; class=&quot;headerlink&quot; title=&quot;printf 格式化输出&quot;&gt;&lt;/a&gt;printf 格式化输出&lt;/h4&gt;&lt;p&gt;printf是awk的一个格式化输出的函数，其格式类似C语言的printf，如下：&lt;br&gt;&lt;figure class=&quot;highlight perl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;I am %s, %d years old.&quot;&lt;/span&gt;, name, age);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;重定向输出&quot;&gt;&lt;a href=&quot;#重定向输出&quot; class=&quot;headerlink&quot; title=&quot;重定向输出&quot;&gt;&lt;/a&gt;重定向输出&lt;/h4&gt;&lt;p&gt;print和printf默认都是输出到stdout（控制台）。通过在print和printf语句后使用”&amp;gt;”操作符可以将输出重定向到文件。如：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print $1 &amp;gt; file;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printf(&lt;span class=&quot;string&quot;&gt;&quot;This is a demo.&quot;&lt;/span&gt;) &amp;gt; file;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何执行awk脚本&quot;&gt;&lt;a href=&quot;#如何执行awk脚本&quot; class=&quot;headerlink&quot; title=&quot;如何执行awk脚本&quot;&gt;&lt;/a&gt;如何执行awk脚本&lt;/h2&gt;&lt;p&gt;执行awk脚本有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如其他脚本语言一样，将awk程序写在文件中，然后执行：&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk -f awk_file dat&lt;span class=&quot;built_in&quot;&gt;a_file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或者直接将代码写在命令行中，用单引号括起来：（这种方式让用户在做一些只需简短命令的文本处理任务时效率很高）&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;...script...&#39;&lt;/span&gt; data_file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;awk还可以使用-F参数指定分隔符&lt;br&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk -&lt;span class=&quot;literal&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;...script...&#39;&lt;/span&gt; data_file	// 以&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;为分隔符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;awk -&lt;span class=&quot;literal&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&#39;[:@*]&#39;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;...script...&#39;&lt;/span&gt; data_file	// 以&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;@&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt;为分隔符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也可以一次处理多个file，awk将按顺序读入&lt;br&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk &#39;...script...&#39; dat&lt;span class=&quot;built_in&quot;&gt;a_file1&lt;/span&gt; dat&lt;span class=&quot;built_in&quot;&gt;a_file2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐书籍&quot;&gt;&lt;a href=&quot;#推荐书籍&quot; class=&quot;headerlink&quot; title=&quot;推荐书籍&quot;&gt;&lt;/a&gt;推荐书籍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;em&gt;The AWK Programming Language&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;awk 是一个强大的文本处理语言，由贝尔实验室在1977年发布，名字取自它的三位创造者 Alfred Aho、Peter Weinberger 和 Brian Kernighan 名字的首字母。作为一个已经有38年历史的工具，awk 如今在文本处理中的地位仍然不可动摇，可称得上是一件上古神器了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.abandonzhang.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何正确存储用户密码</title>
    <link href="http://blog.abandonzhang.me/2015/11/09/Password/"/>
    <id>http://blog.abandonzhang.me/2015/11/09/Password/</id>
    <published>2015-11-09T10:55:38.000Z</published>
    <updated>2018-01-21T10:14:19.672Z</updated>
    
    <content type="html">&lt;p&gt;密码的用处在于保护用户的隐私，防止他人登录到用户的系统中获取用户的信息或做一些其他不(xiu)好(xiu)的事情。应用程序肯定需要存储用户的密码以便在用户登录时判断用户输入的密码是否正确。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;几乎每一个人都知道数据库里不应该保存密码的明文，除了CSDN。我也不知道CSDN是怎么想的，大概他们觉得自己的数据库永远不会泄露，顺便想翻翻数据库看看用户的密码……&lt;/p&gt;
&lt;h2 id=&quot;普通哈希存储&quot;&gt;&lt;a href=&quot;#普通哈希存储&quot; class=&quot;headerlink&quot; title=&quot;普通哈希存储&quot;&gt;&lt;/a&gt;普通哈希存储&lt;/h2&gt;&lt;p&gt;有不少人觉得数据库里存密码的MD5值似乎没有问题。事实上所有的哈希算法，包括比MD5更难破解的SHA-256等等都有这样的问题，它们虽然很难被正面破解，但是很容易通过查表法破解出来。&lt;/p&gt;
&lt;p&gt;什么意思呢？我可以用一台服务器枚举所有的字符串（理论可行，实际上可以枚举些常用或者长度小的密码），预先计算出这些字符串的MD5/SHA-256值保存起来，然后拿到一个MD5/SHA-256值之后从这个库中查出对应的原文即可。&lt;/p&gt;
&lt;p&gt;还有一种时空复杂度折中的方法叫做彩虹表，更是屡试不爽的破解密码的利器。（过后介绍）&lt;/p&gt;
&lt;h2 id=&quot;加盐哈希存储&quot;&gt;&lt;a href=&quot;#加盐哈希存储&quot; class=&quot;headerlink&quot; title=&quot;加盐哈希存储&quot;&gt;&lt;/a&gt;加盐哈希存储&lt;/h2&gt;&lt;p&gt;一个有效防止上面攻击手段的方法就是加盐后再哈希，盐就是附加在用户密码后面的一个随机字符串，加盐哈希就是诸如MD5(password+salt)这样的方式，当然可以用更难破解的哈希函数SHA-256。&lt;/p&gt;
&lt;p&gt;这样做有什么好处呢：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以防止彩虹表的构造&lt;br&gt;要注意的是不要使用固定的盐值。一旦攻击者获取到这个盐值后就可以根据这个固定的盐值来构造彩虹表破解所有用户的密码。&lt;/li&gt;
&lt;li&gt;可以加长哈希明文的长度，提高暴力或查表破解的难度。&lt;br&gt;比如我们给用户的密码加个32位的盐值，那攻击者就需要枚举32+密码长度的字符串来保存字典，这样的代价是很大的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以目前一个比较安全的存储密码的方案就是将用户的密码加上一个随机盐进行哈希，然后在把相应的哈希值和盐值存到数据库中供校验使用。&lt;/p&gt;
&lt;p&gt;目前先写到这里，后续话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免多次哈希&lt;/li&gt;
&lt;li&gt;慢哈希&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;密码的用处在于保护用户的隐私，防止他人登录到用户的系统中获取用户的信息或做一些其他不(xiu)好(xiu)的事情。应用程序肯定需要存储用户的密码以便在用户登录时判断用户输入的密码是否正确。&lt;/p&gt;
    
    </summary>
    
    
      <category term="信息安全" scheme="http://blog.abandonzhang.me/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Automata - Regular Language</title>
    <link href="http://blog.abandonzhang.me/2015/10/18/Regular-Languages/"/>
    <id>http://blog.abandonzhang.me/2015/10/18/Regular-Languages/</id>
    <published>2015-10-18T08:52:40.000Z</published>
    <updated>2018-01-21T10:14:19.670Z</updated>
    
    <content type="html">&lt;p&gt;斯坦福大学公开课Automata学习笔记系列（二）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.abandonzhang.me/2015/10/15/Finite-Automaton/&quot;&gt;上次&lt;/a&gt;说过，三种有穷自动机（DFA、NFA、ε-NFA）是等价的而且它们能接受的语言都是正则语言。那今天就来说说正则语言。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式（Regular-Expression）&quot;&gt;&lt;a href=&quot;#正则表达式（Regular-Expression）&quot; class=&quot;headerlink&quot; title=&quot;正则表达式（Regular Expression）&quot;&gt;&lt;/a&gt;正则表达式（Regular Expression）&lt;/h2&gt;&lt;p&gt;正则语言最常用的表示方式就是正则表达式，它包含两个要素：1.字符（∈字母表Σ）2.操作符。&lt;/p&gt;
&lt;p&gt;正则语言的操作有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concatenation&lt;br&gt;两个正则语言L和M串联的结果LM，是L中每个句子（字符串）尾部分别加上M中的每个句子所组成句子的集合。Example：{01,111,10}{00, 01} = {0100, 0101, 11100, 11101, 1000, 1001}。&lt;/li&gt;
&lt;li&gt;Union&lt;br&gt;两个正则语言L和M的并集L∪M，就是L的句子集与M的句子集的并集。Example：{01,111,10}∪{00, 01} = {01,111,10,00}。&lt;/li&gt;
&lt;li&gt;Kleene Star&lt;br&gt;正则语言L的克莱尼星L*是将0个L串联、1个L串联、……、n个L串联结果的并集。Example：{0,10}* = {ε, 0, 10, 00, 010, 100, 1010, …}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果E1、E2是两个正则表达式，它们表示的正则语言分别是L(E1)和L(E2)，则有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L(E1+E2) = L(E1)∪L(E2)&lt;/li&gt;
&lt;li&gt;L(E1E2) = L(E1)L(E2)&lt;/li&gt;
&lt;li&gt;L(E1*) = L(E1)*&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;正则语言的特性&quot;&gt;&lt;a href=&quot;#正则语言的特性&quot; class=&quot;headerlink&quot; title=&quot;正则语言的特性&quot;&gt;&lt;/a&gt;正则语言的特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;闭包（Closure）&lt;ul&gt;
&lt;li&gt;任意两个正则语言的Concatenation、Union、Kleene Star操作的结果仍然是正则语言。&lt;/li&gt;
&lt;li&gt;正则语言的差集L-M仍然是正则语言。&lt;/li&gt;
&lt;li&gt;正则语言的补集Σ*-L仍然是正则语言。&lt;/li&gt;
&lt;li&gt;正则语言的同构（映射关系h(0)=ab）仍然是正则语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单位元和零元：&lt;ul&gt;
&lt;li&gt;∅是Union操作的单位元。即R+∅=R。&lt;/li&gt;
&lt;li&gt;ε是Concatenation操作的单位元。即Rε=εR=R。&lt;/li&gt;
&lt;li&gt;∅是Concatenation操作的零元。即R∅=∅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断句子（字符串）是否属于正则语言L：&lt;ul&gt;
&lt;li&gt;判断句子是否被表示正则语言L的DFA所接受。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断一个正则语言是否是空集：&lt;ul&gt;
&lt;li&gt;判断表示正则语言的DFA的终止状态是否可达。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断一个正则语言是否是一个无穷集合：&lt;ul&gt;
&lt;li&gt;如果表示正则语言的DFA有n个状态，而该正则语言有长度大于n的句子，则该正则语言一定是无穷集合。（有环）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泵引理&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;对于任何一个正则语言L，都存在一个整数n（–&amp;gt; DFA状态数），对于任何一个长度大于n的L的字符串，都可以写成w=xyz的形式，其中：&lt;ul&gt;
&lt;li&gt;|xy| &amp;lt; n&lt;/li&gt;
&lt;li&gt;|y| &amp;gt; 0&lt;/li&gt;
&lt;li&gt;所有的i &amp;gt;= 0，xy^iz都属于这个正则语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断两个正则语言L和M是否相等 –&amp;gt; 判断表示L和M的DFA是否相等：&lt;ul&gt;
&lt;li&gt;构造一个新的DFA，其状态集是L和M的状态集的笛卡尔积(q,r)&lt;/li&gt;
&lt;li&gt;δ([q,p], a) = [δ_L(q,a), δ_M(p,a)]&lt;/li&gt;
&lt;li&gt;对于一个新DFA的状态[q,p]，如果q和p其中有且仅有一个是L或M的终止状态，则[q,p]是新DFA的终止状态&lt;/li&gt;
&lt;li&gt;L和M相等 –&amp;gt; 新的DFA的终止状态不可达&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“最小化”DFA –&amp;gt; 去掉“相同”的状态&lt;ul&gt;
&lt;li&gt;对于DFA的任意两个状态，如果其中有且仅有一个状态，则这两个状态是不同的&lt;/li&gt;
&lt;li&gt;对于任意的状态q和p，如果δ(q,a)和δ(p,a)不同，则q和p不同&lt;/li&gt;
&lt;li&gt;合并剩下“相同”的状态&lt;/li&gt;
&lt;li&gt;去掉不可达的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则表达式与FA的等价与转换&quot;&gt;&lt;a href=&quot;#正则表达式与FA的等价与转换&quot; class=&quot;headerlink&quot; title=&quot;正则表达式与FA的等价与转换&quot;&gt;&lt;/a&gt;正则表达式与FA的等价与转换&lt;/h2&gt;&lt;p&gt;（一）正则表达式可以很方便地构造出对应的ε-NFA：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concatenation&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/AutomataQQ20151018-1@2x.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/AutomataQQ20151018-2@2x.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kleene Star&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/AutomataQQ20151018-3@2x.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（二）DFA向正则表达式转换有一点点难，需要一点动态规划和归纳的思想，接触过Floyd算法的理解起来会比较方便。算法描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Desc：将DFA的状态标为（1, …, n），D(i,j,k)表示从DFA的状态i到状态j，中间只能经过不大于k的状态所表示的正则表达式。&lt;/li&gt;
&lt;li&gt;Base：k=0，D(i,j,0) = union{从状态i转移到状态j的字符}&lt;/li&gt;
&lt;li&gt;Induction：&lt;ul&gt;
&lt;li&gt;假设当前所有小于k的D(i,j,)表达式都已经算出&lt;/li&gt;
&lt;li&gt;D(i,j,k) = D(i,j,k-1) + D(i,k,k-1)(D(k,k,k-1))*D(k,j,k-1)}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Final：DFA所表示的正则表达式=Union{D(i,j,n)|i=起始状态，j∈终止状态，n=DFA状态数}&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;斯坦福大学公开课Automata学习笔记系列（二）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自动机理论" scheme="http://blog.abandonzhang.me/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的闭包</title>
    <link href="http://blog.abandonzhang.me/2015/10/16/Closure/"/>
    <id>http://blog.abandonzhang.me/2015/10/16/Closure/</id>
    <published>2015-10-16T09:20:02.000Z</published>
    <updated>2018-01-21T10:14:19.669Z</updated>
    
    <content type="html">&lt;p&gt;闭包（Closure）本身其实是一个数学概念，表示一个特殊的集合（Set），该集合中任意元素间的运算结果仍然是这个集合中的元素。而我们码农常常也会谈论编程语言中的一个“闭包”，其实是词法闭包（Lexical Closure），用来支持匿名函数和嵌套定义函数这些特性。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h2&gt;&lt;p&gt;匿名函数是指不需要定义标识符（函数名）的函数。通常可以像以下形式一样定义一个函数并把它关联给一个变量：&lt;br&gt;&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#Javascript Style&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myFun = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// code here ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myFun();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是我觉得其实这样并没有什么卵用……和正常定义一个函数没什么区别呀。所以，匿名函数更常用的情景应该是作为回调函数或者“嵌套定义”。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;回调函数&lt;/p&gt;
&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#Javascript Style&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#假设现在有一个注册事件registerEvent(func, args)表示当发生某个事件时调用这个回调函数处理某些事情，我们可以这样写：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;registerEvent(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“嵌套定义”&lt;br&gt;嵌套定义一个函数一般是定义一些行为相似只是某些参数不同的函数，常见的场景就是函数的嵌套定义，通过外层函数包装，来决定里层函数的最终内容： &lt;/p&gt;
&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#Javascript Style&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generateFunc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myFun = generateFunc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(myFun(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;很多人把匿名函数和闭包混为一谈，而实际上匿名函数和闭包是两回事。闭包常用于嵌套定义中，是指内部匿名函数可以使用外部函数的局部变量（即使外部函数的生命周期结束）。举个栗子：&lt;br&gt;&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#Javascript Style &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generateFunc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num + x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myFun = generateFunc(); &lt;span class=&quot;comment&quot;&gt;// (*)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(myFun(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个代码和它上面的代码实现了同样的功能，而这个代码则需要使用闭包才能使其正常运行。因为在(*)处调用generateFunc()函数后，其生命周期已经结束，按理说num这个局部变量的生命周期也应该结束，然而在下面调用匿名函数的时候还是用到了这个变量。&lt;/p&gt;
&lt;p&gt;有的人（包括我）一开始会觉得说可能在返回这个匿名函数的时候num已经被替换成了10，其实不是这样的，再来看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#Javascript Style &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myFun = go();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.write(myFun());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.write(myFun());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.write(myFun());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出10 11 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子也是可以正常运行的，这证明匿名函数确实是使用了外部函数的局部变量num。&lt;/p&gt;
&lt;h2 id=&quot;各编程语言中的闭包&quot;&gt;&lt;a href=&quot;#各编程语言中的闭包&quot; class=&quot;headerlink&quot; title=&quot;各编程语言中的闭包&quot;&gt;&lt;/a&gt;各编程语言中的闭包&lt;/h2&gt;&lt;p&gt;（未完待续……）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;闭包（Closure）本身其实是一个数学概念，表示一个特殊的集合（Set），该集合中任意元素间的运算结果仍然是这个集合中的元素。而我们码农常常也会谈论编程语言中的一个“闭包”，其实是词法闭包（Lexical Closure），用来支持匿名函数和嵌套定义函数这些特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级编程语言特性" scheme="http://blog.abandonzhang.me/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Automata - Finite Automata</title>
    <link href="http://blog.abandonzhang.me/2015/10/15/Finite-Automaton/"/>
    <id>http://blog.abandonzhang.me/2015/10/15/Finite-Automaton/</id>
    <published>2015-10-15T11:16:22.000Z</published>
    <updated>2018-01-21T10:14:19.664Z</updated>
    
    <content type="html">&lt;p&gt;Stanford CS154 &lt;a href=&quot;http://web.stanford.edu/~rrwill/cs154-2016/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Automata and Complexity Theory&lt;/a&gt; 学习笔记（一）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Automata&quot;&gt;&lt;a href=&quot;#Automata&quot; class=&quot;headerlink&quot; title=&quot;Automata&quot;&gt;&lt;/a&gt;Automata&lt;/h2&gt;&lt;p&gt;Automata是一种抽象计算模型，它可以接收输入的字符&lt;/p&gt;
&lt;p&gt;有穷自动机就是一个字符串模式匹配的数学模型。这个类别，大，可以是一种“语言”（判断这行代码是否符合Java规范）；小，也可以是一个“模式”（判断字符串是否能被给定的正则表达式匹配）。&lt;/p&gt;
&lt;h2 id=&quot;有穷自动机的定义&quot;&gt;&lt;a href=&quot;#有穷自动机的定义&quot; class=&quot;headerlink&quot; title=&quot;有穷自动机的定义&quot;&gt;&lt;/a&gt;有穷自动机的定义&lt;/h2&gt;&lt;p&gt;一个有穷自动机FA如下图所示：&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/Automata屏幕快照%202015-12-14%2018.31.58.png?imageView2/2/h/250&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它按顺序依次处理输入字符串的每一个字符。&lt;/li&gt;
&lt;li&gt;维护一个有穷的集合Σ，来表示这种“语言”接受的字符（比如英语，就只接受a-z,A-Z,空格和一堆英文标点）。&lt;/li&gt;
&lt;li&gt;维护一个有穷的状态集合Q，来表示当前处理到了哪个“阶段”。这个“阶段”不是简单的第一步第二步，而是更复杂的一些状态；其中一个状态作为FA的初始状态，另外也有一些状态作为终止状态；&lt;/li&gt;
&lt;li&gt;如果FA从起始状态开始，按顺序处理字符串所有的字符后最终到达一个终止状态，则该字符串被FA接受。&lt;/li&gt;
&lt;li&gt;维护一个状态转移函数δ，告诉自动机在当前状态下处理下一个字符时要转变到哪个状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，有穷自动机可以形式化定义为一个 $(Q, Σ, \delta, q_0, F)$ 的五元组，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Q$，状态的有穷集合&lt;/li&gt;
&lt;li&gt;$Σ$，输入字符的有穷集合 —— 字母表（alphabet）&lt;/li&gt;
&lt;li&gt;$\delta$，状态转移函数（transition function）&lt;/li&gt;
&lt;li&gt;$q_0$，起始状态，$\in Q$&lt;/li&gt;
&lt;li&gt;$F$，终止状态的集合，$\subseteq Q$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;有穷自动机的表示&quot;&gt;&lt;a href=&quot;#有穷自动机的表示&quot; class=&quot;headerlink&quot; title=&quot;有穷自动机的表示&quot;&gt;&lt;/a&gt;有穷自动机的表示&lt;/h2&gt;&lt;p&gt;表示有穷自动机有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态图（State diagram）&lt;br&gt;如下图所示：一个圆表示一个状态；一个start箭头指向的圆是起始状态，圆内有环表示是一个终止状态；箭头和文字表示当前状态下输入下一个字符后状态的转移方向。&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/Automata屏幕快照%202015-12-18%2018.50.58.png?imageView2/2/h/150&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;状态转移表（State transition table）&lt;br&gt;如下表所示：表描述了一个矩阵关系。左边的列表示所有的状态，其中状态前加*表示是一个终止状态；上面的行表示所有的可接受字符；矩阵的值表示在对应的状态下输入下一个字符后可转移的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*B&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;状态图表达起来更直观，但状态转移表可以更清晰的表达出状态转移关系（状态转移函数）。&lt;/p&gt;
&lt;h2 id=&quot;DFA：确定型有穷自动机&quot;&gt;&lt;a href=&quot;#DFA：确定型有穷自动机&quot; class=&quot;headerlink&quot; title=&quot;DFA：确定型有穷自动机&quot;&gt;&lt;/a&gt;DFA：确定型有穷自动机&lt;/h2&gt;&lt;p&gt;确定型有穷自动机（Deterministic Finite Automaton），简称DFA，其特点是：有穷自动机在当前状态下输入下一个字符，转移后的状态是唯一的。例如上节中的状态图和状态转移表所对应的有穷自动机就是DFA。&lt;/p&gt;
&lt;h3 id=&quot;DFA的状态转移函数&quot;&gt;&lt;a href=&quot;#DFA的状态转移函数&quot; class=&quot;headerlink&quot; title=&quot;DFA的状态转移函数&quot;&gt;&lt;/a&gt;DFA的状态转移函数&lt;/h3&gt;&lt;p&gt;DFA的状态转移函数 $\delta(q, a) = p$ 定义为 $f : Q * Σ \rightarrow Q$ ，其两个参数分别表示当前的状态q和下一个输入的字符a，输出的结果p是转移后的状态。&lt;/p&gt;
&lt;p&gt;通常我们都会扩展一下 $\delta$ 的概念，使其可以计算一个状态在输入一连串字符后的状态：$$ \delta(q, w) = f : Q * Σ^* \rightarrow Q $$ 其中， $Σ^*$ 表示所有字符串的集合。&lt;/p&gt;
&lt;p&gt;为了给出 $\delta(q, w)$ 的定义，需要引出一个新的符号 $\varepsilon$ ，表示一个空的字符串””。&lt;/p&gt;
&lt;p&gt;然后我们给出 $\delta(q, w)$ 在DFA中的归纳定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Base: \delta(q, \varepsilon) = q$&lt;/li&gt;
&lt;li&gt;$Induction: \delta(q, wa) = \delta(\delta(q, w), a)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;DFA接受的语言&quot;&gt;&lt;a href=&quot;#DFA接受的语言&quot; class=&quot;headerlink&quot; title=&quot;DFA接受的语言&quot;&gt;&lt;/a&gt;DFA接受的语言&lt;/h3&gt;&lt;p&gt;如果一个字符串w，在有穷自动机上从起始状态 $q_0$ 开始经过状态转移 $\delta(q_0, w)$ 后得到一个终止状态，则字符串w被该有穷自动机接受。&lt;/p&gt;
&lt;p&gt;被一个有穷自动机M接受的字符串的集合就是被M接受的语言，其中的每个字符串都是一个句子。一种语言对应一个有穷自动机。&lt;/p&gt;
&lt;p&gt;被DFA接受的语言叫正则语言。&lt;/p&gt;
&lt;h2 id=&quot;NFA：非确定型有穷自动机&quot;&gt;&lt;a href=&quot;#NFA：非确定型有穷自动机&quot; class=&quot;headerlink&quot; title=&quot;NFA：非确定型有穷自动机&quot;&gt;&lt;/a&gt;NFA：非确定型有穷自动机&lt;/h2&gt;&lt;p&gt;非确定型有穷自动机（Nondeterministic Finite Automaton），简称NFA。跟确定相反，非确定的意思就是在当前状态下输入下一个字符，转移后的状态不是唯一的。如下图所示：&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/Automata屏幕快照%202015-12-18%2019.07.12.png?imageView2/2/h/150&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;NFA的状态转移函数&quot;&gt;&lt;a href=&quot;#NFA的状态转移函数&quot; class=&quot;headerlink&quot; title=&quot;NFA的状态转移函数&quot;&gt;&lt;/a&gt;NFA的状态转移函数&lt;/h3&gt;&lt;p&gt;NFA的状态转移函数 $\delta(q, a) = \{q_1, q_2, …\}$ 定义为 $f : Q * Σ \rightarrow P(Q)$，其中P(Q)表示Q的幂集。&lt;/p&gt;
&lt;p&gt;NFA的状态转移函数也可以扩展成 $\delta(q, w)$ ，其归纳定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Base: \delta(q, \varepsilon) = \{q\}$&lt;/li&gt;
&lt;li&gt;$Induction: \delta(q, wa) = \bigcup \{\delta(p, a), p \in \delta(q, w)\}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;NFA和DFA的等价性&quot;&gt;&lt;a href=&quot;#NFA和DFA的等价性&quot; class=&quot;headerlink&quot; title=&quot;NFA和DFA的等价性&quot;&gt;&lt;/a&gt;NFA和DFA的等价性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DFA到NFA&lt;ul&gt;
&lt;li&gt;DFA本身就是一个特殊的NFA：$\delta_{DFA}(q, a) = p \Leftrightarrow \delta_{NFA}(q, a) = \{p\} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NFA到DFA：给定一个NFA，可以构造出一个等价的DFA&lt;ul&gt;
&lt;li&gt;对于NFA中出现的包含多个状态的集合 $\{q_0, …, q_k\}$，对应在DFA中增加”一个状态” $\{q_0, …, q_k\}$。&lt;/li&gt;
&lt;li&gt;DFA中对应的状态转移函数: $$\delta_{DFA}(\{q_0, …, q_k\}, a) = \bigcup \{ \delta_{NFA}(q, a), q \in [0, k] \}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，&lt;strong&gt;DFA与NFA是等价的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;epsilon-NFA&quot;&gt;&lt;a href=&quot;#epsilon-NFA&quot; class=&quot;headerlink&quot; title=&quot;epsilon-NFA&quot;&gt;&lt;/a&gt;epsilon-NFA&lt;/h2&gt;&lt;p&gt;$\varepsilon$-NFA的输入字符可以是$\varepsilon$“空字符”，即 $\varepsilon$-NFA不必等到输入下一个字符就可完成一次状态转移。如下图所示：&lt;br&gt;&lt;img src=&quot;http://7rflnz.com1.z0.glb.clouddn.com/Automata屏幕快照%202015-12-18%2019.07.18.png?imageView2/2/h/150&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;状态闭包&quot;&gt;&lt;a href=&quot;#状态闭包&quot; class=&quot;headerlink&quot; title=&quot;状态闭包&quot;&gt;&lt;/a&gt;状态闭包&lt;/h3&gt;&lt;p&gt;定义状态q的闭包 $CL(q)$ 为：在状态q下，只经过ε转移能够到达的状态的集合。例如在上图中，$CL(D) = \{B, A\}$。&lt;/p&gt;
&lt;p&gt;状态集合的闭包就是各状态的闭包的并集，$CL(\{q_0, …, q_k\}) = \bigcup \{Q = CL(q_i), i \in [0, k]\}$。&lt;/p&gt;
&lt;h3 id=&quot;Extended-Delta-扩展δ&quot;&gt;&lt;a href=&quot;#Extended-Delta-扩展δ&quot; class=&quot;headerlink&quot; title=&quot;Extended Delta : 扩展δ&quot;&gt;&lt;/a&gt;Extended Delta : 扩展δ&lt;/h3&gt;&lt;p&gt;有了状态的闭包后，我们需要再次扩展δ函数，并且这次扩展后的δ有了新的名称：Extended Delta：&lt;/p&gt;
&lt;p&gt;// Extended Delta的归纳定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base: ex_δ(q, ε) = CL(q)&lt;/li&gt;
&lt;li&gt;Induction: ex_δ(q, wa) = CL(δ(p, a)), p ∈ S, S = ex_δ(q, w)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ε-NFA和NFA的等价性&quot;&gt;&lt;a href=&quot;#ε-NFA和NFA的等价性&quot; class=&quot;headerlink&quot; title=&quot;ε-NFA和NFA的等价性&quot;&gt;&lt;/a&gt;ε-NFA和NFA的等价性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NFA到ε-NFA&lt;ul&gt;
&lt;li&gt;NFA本身就是一个特殊的ε-NFA。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ε-NFA到NFA：给定一个ε-NFA，可以构造出一个等价的NFA&lt;ul&gt;
&lt;li&gt;对于ε-NFA中的每一个状态q，它的状态转移函数ex_δ(q, a)等价于NFA中的状态转移函数δ(q, a) = { p | p = ex_δ(q&lt;em&gt;, a), q&lt;/em&gt; ∈CL(q) }。&lt;/li&gt;
&lt;li&gt;对于ε-NFA中的每一个终止状态，如果它在另一个状态的闭包中，则把另一个状态也加入终止状态，直到没有新的终止状态加入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DFA，NFA，ε-NFA三者是等价的。并且他们接受的语言也是一样的，都是正则语言。&lt;/li&gt;
&lt;li&gt;NFA较DFA来说更好设计出来，并且状态也会比等价的DFA少很多。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Only a DFA can be implemented&lt;/em&gt; —— Jeff Ullman。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Stanford CS154 &lt;a href=&quot;http://web.stanford.edu/~rrwill/cs154-2016/&quot;&gt;Automata and Complexity Theory&lt;/a&gt; 学习笔记（一）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="自动机理论" scheme="http://blog.abandonzhang.me/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>
